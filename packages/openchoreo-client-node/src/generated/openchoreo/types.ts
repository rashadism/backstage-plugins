/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Health check
     * @description Returns OK if the server is healthy. Used for liveness probes.
     */
    get: operations['getHealth'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ready': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Readiness check
     * @description Returns Ready if the server is ready to accept requests. Used for readiness probes.
     */
    get: operations['getReady'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get server version
     * @description Returns version information about the API server.
     */
    get: operations['getVersion'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/openapi.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get OpenAPI specification
     * @description Returns the OpenAPI 3.0 specification for this API in JSON format.
     */
    get: operations['getOpenAPISpec'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/.well-known/oauth-protected-resource': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get OAuth protected resource metadata
     * @description Returns OAuth 2.0 protected resource metadata as defined in RFC 9728.
     *     Used by MCP clients and the CLI to discover authorization server information
     *     and client configurations.
     *
     *     OpenChoreo-specific extension fields (RFC 9728 ยง2):
     *     - `openchoreo_clients`: OAuth client configurations for integrations (e.g., CLI).
     *     - `openchoreo_security_enabled`: Whether authentication is enforced on this server.
     */
    get: operations['getOAuthProtectedResourceMetadata'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List namespaces
     * @description Returns a paginated list of OpenChoreo control plane namespaces the user has access to.
     *     Only namespaces with the label `openchoreo.dev/controlplane-namespace=true` are returned.
     *     This filters out system namespaces (e.g., openchoreo-control-plane, kube-system) and
     *     data plane runtime namespaces.
     */
    get: operations['listNamespaces'];
    put?: never;
    /**
     * Create namespace
     * @description Creates a new OpenChoreo control plane namespace.
     *     The namespace is automatically labeled with `openchoreo.dev/controlplane-namespace=true`.
     */
    post: operations['createNamespace'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get namespace
     * @description Returns details of a specific namespace.
     */
    get: operations['getNamespace'];
    /**
     * Update namespace
     * @description Replaces an existing control plane namespace (full update).
     */
    put: operations['updateNamespace'];
    post?: never;
    /**
     * Delete namespace
     * @description Deletes a control plane namespace by name.
     */
    delete: operations['deleteNamespace'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/projects': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List projects
     * @description Returns a paginated list of projects within an namespace.
     */
    get: operations['listProjects'];
    put?: never;
    /**
     * Create project
     * @description Creates a new project within an namespace.
     */
    post: operations['createProject'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/projects/{projectName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get project
     * @description Returns details of a specific project.
     */
    get: operations['getProject'];
    /**
     * Update project
     * @description Replaces an existing project (full update).
     */
    put: operations['updateProject'];
    post?: never;
    /**
     * Delete project
     * @description Deletes a project by name.
     */
    delete: operations['deleteProject'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/components': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List components
     * @description Returns a paginated list of components within a namespace, optionally filtered by project.
     */
    get: operations['listComponents'];
    put?: never;
    /**
     * Create component
     * @description Creates a new component within a namespace.
     */
    post: operations['createComponent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/environments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List environments
     * @description Returns a paginated list of environments within an namespace.
     */
    get: operations['listEnvironments'];
    put?: never;
    /**
     * Create environment
     * @description Creates a new environment within an namespace.
     */
    post: operations['createEnvironment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/environments/{envName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get environment
     * @description Returns details of a specific environment.
     */
    get: operations['getEnvironment'];
    /**
     * Update environment
     * @description Replaces an existing environment (full update).
     */
    put: operations['updateEnvironment'];
    post?: never;
    /**
     * Delete environment
     * @description Deletes an environment by name.
     */
    delete: operations['deleteEnvironment'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/environments/{envName}/observer-url': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get environment observer URL
     * @description Returns the observer URL for accessing logs and metrics for this environment.
     */
    get: operations['getEnvironmentObserverURL'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/environments/{envName}/rca-agent-url': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get RCA agent URL
     * @description Returns the RCA agent URL for AI-powered root cause analysis for this environment.
     */
    get: operations['getRCAAgentURL'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/dataplanes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List data planes
     * @description Returns a paginated list of data planes within an namespace.
     */
    get: operations['listDataPlanes'];
    put?: never;
    /**
     * Create data plane
     * @description Creates a new data plane within an namespace.
     */
    post: operations['createDataPlane'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/dataplanes/{dpName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get data plane
     * @description Returns details of a specific data plane.
     */
    get: operations['getDataPlane'];
    /**
     * Update data plane
     * @description Replaces an existing data plane (full update).
     */
    put: operations['updateDataPlane'];
    post?: never;
    /**
     * Delete data plane
     * @description Deletes a data plane by name.
     */
    delete: operations['deleteDataPlane'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/buildplanes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List build planes
     * @description Returns a paginated list of build planes within a namespace. Typically one per namespace.
     */
    get: operations['listBuildPlanes'];
    put?: never;
    /**
     * Create build plane
     * @description Creates a new build plane within a namespace.
     */
    post: operations['createBuildPlane'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/buildplanes/{buildPlaneName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get build plane
     * @description Returns details of a specific build plane.
     */
    get: operations['getBuildPlane'];
    /**
     * Update build plane
     * @description Replaces an existing build plane (full update).
     */
    put: operations['updateBuildPlane'];
    post?: never;
    /**
     * Delete build plane
     * @description Deletes a build plane by name.
     */
    delete: operations['deleteBuildPlane'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/observabilityplanes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List observability planes
     * @description Returns a paginated list of observability planes within a namespace.
     */
    get: operations['listObservabilityPlanes'];
    put?: never;
    /**
     * Create observability plane
     * @description Creates a new observability plane within a namespace.
     */
    post: operations['createObservabilityPlane'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/observabilityplanes/{observabilityPlaneName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get observability plane
     * @description Returns details of a specific observability plane.
     */
    get: operations['getObservabilityPlane'];
    /**
     * Update observability plane
     * @description Replaces an existing observability plane (full update).
     */
    put: operations['updateObservabilityPlane'];
    post?: never;
    /**
     * Delete observability plane
     * @description Deletes an observability plane by name.
     */
    delete: operations['deleteObservabilityPlane'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterdataplanes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List cluster data planes
     * @description Returns a paginated list of cluster-scoped data planes.
     */
    get: operations['listClusterDataPlanes'];
    put?: never;
    /**
     * Create cluster data plane
     * @description Creates a new cluster-scoped data plane.
     */
    post: operations['createClusterDataPlane'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterdataplanes/{cdpName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get cluster data plane
     * @description Returns details of a specific cluster-scoped data plane.
     */
    get: operations['getClusterDataPlane'];
    /**
     * Update cluster data plane
     * @description Replaces an existing cluster-scoped data plane (full update).
     */
    put: operations['updateClusterDataPlane'];
    post?: never;
    /**
     * Delete cluster data plane
     * @description Deletes a cluster-scoped data plane by name.
     */
    delete: operations['deleteClusterDataPlane'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterbuildplanes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List cluster build planes
     * @description Returns a list of cluster-scoped build planes.
     */
    get: operations['listClusterBuildPlanes'];
    put?: never;
    /**
     * Create cluster build plane
     * @description Creates a new cluster-scoped build plane.
     */
    post: operations['createClusterBuildPlane'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterbuildplanes/{clusterBuildPlaneName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a cluster build plane
     * @description Returns details of a specific cluster-scoped build plane.
     */
    get: operations['getClusterBuildPlane'];
    /**
     * Update cluster build plane
     * @description Replaces an existing cluster-scoped build plane (full update).
     */
    put: operations['updateClusterBuildPlane'];
    post?: never;
    /**
     * Delete cluster build plane
     * @description Deletes a cluster-scoped build plane by name.
     */
    delete: operations['deleteClusterBuildPlane'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterobservabilityplanes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List cluster observability planes
     * @description Returns a paginated list of cluster-scoped observability planes.
     */
    get: operations['listClusterObservabilityPlanes'];
    put?: never;
    /**
     * Create cluster observability plane
     * @description Creates a new cluster-scoped observability plane.
     */
    post: operations['createClusterObservabilityPlane'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterobservabilityplanes/{clusterObservabilityPlaneName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a cluster observability plane
     * @description Returns details of a specific cluster-scoped observability plane.
     */
    get: operations['getClusterObservabilityPlane'];
    /**
     * Update cluster observability plane
     * @description Replaces an existing cluster observability plane (full update).
     */
    put: operations['updateClusterObservabilityPlane'];
    post?: never;
    /**
     * Delete cluster observability plane
     * @description Deletes a cluster observability plane by name.
     */
    delete: operations['deleteClusterObservabilityPlane'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clustercomponenttypes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List cluster component types
     * @description Returns a list of cluster-scoped component types.
     */
    get: operations['listClusterComponentTypes'];
    put?: never;
    /**
     * Create cluster component type
     * @description Creates a new cluster-scoped component type.
     */
    post: operations['createClusterComponentType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clustercomponenttypes/{cctName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a cluster component type
     * @description Returns details of a specific cluster-scoped component type.
     */
    get: operations['getClusterComponentType'];
    /**
     * Update cluster component type
     * @description Replaces an existing cluster-scoped component type (full update).
     */
    put: operations['updateClusterComponentType'];
    post?: never;
    /**
     * Delete cluster component type
     * @description Deletes a cluster-scoped component type by name.
     */
    delete: operations['deleteClusterComponentType'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clustercomponenttypes/{cctName}/schema': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get cluster component type schema
     * @description Returns the parameter schema for a specific cluster-scoped component type.
     */
    get: operations['getClusterComponentTypeSchema'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clustertraits': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List cluster traits
     * @description Returns a list of cluster-scoped traits.
     */
    get: operations['listClusterTraits'];
    put?: never;
    /**
     * Create cluster trait
     * @description Creates a new cluster-scoped trait.
     */
    post: operations['createClusterTrait'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clustertraits/{clusterTraitName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a cluster trait
     * @description Returns details of a specific cluster-scoped trait.
     */
    get: operations['getClusterTrait'];
    /**
     * Update cluster trait
     * @description Replaces an existing cluster-scoped trait (full update).
     */
    put: operations['updateClusterTrait'];
    post?: never;
    /**
     * Delete cluster trait
     * @description Deletes a cluster-scoped trait by name.
     */
    delete: operations['deleteClusterTrait'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clustertraits/{clusterTraitName}/schema': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get cluster trait schema
     * @description Returns the parameter schema for a specific cluster-scoped trait.
     */
    get: operations['getClusterTraitSchema'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/componenttypes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List component types
     * @description Returns a paginated list of component types available in the namespace.
     */
    get: operations['listComponentTypes'];
    put?: never;
    /**
     * Create component type
     * @description Creates a new component type within a namespace.
     */
    post: operations['createComponentType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/componenttypes/{ctName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get component type
     * @description Returns details of a specific component type.
     */
    get: operations['getComponentType'];
    /**
     * Update component type
     * @description Replaces an existing component type (full update).
     */
    put: operations['updateComponentType'];
    post?: never;
    /**
     * Delete component type
     * @description Deletes a component type by name.
     */
    delete: operations['deleteComponentType'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/componenttypes/{ctName}/schema': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get component type schema
     * @description Returns the parameter schema for a specific component type.
     */
    get: operations['getComponentTypeSchema'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/traits': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List traits
     * @description Returns a paginated list of traits available in the namespace.
     */
    get: operations['listTraits'];
    put?: never;
    /**
     * Create trait
     * @description Creates a new trait within a namespace.
     */
    post: operations['createTrait'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/traits/{traitName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get trait
     * @description Returns details of a specific trait.
     */
    get: operations['getTrait'];
    /**
     * Update trait
     * @description Replaces an existing trait (full update).
     */
    put: operations['updateTrait'];
    post?: never;
    /**
     * Delete trait
     * @description Deletes a trait by name.
     */
    delete: operations['deleteTrait'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/traits/{traitName}/schema': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get trait schema
     * @description Returns the parameter schema for a specific trait.
     */
    get: operations['getTraitSchema'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List workflows
     * @description Returns a list of generic workflows available in the namespace.
     */
    get: operations['listWorkflows'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workflows/{workflowName}/schema': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get workflow schema
     * @description Returns the parameter schema for a specific workflow.
     */
    get: operations['getWorkflowSchema'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workflow-runs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List workflow runs
     * @description Returns a list of generic workflow runs in the namespace.
     */
    get: operations['listWorkflowRuns'];
    put?: never;
    /**
     * Create workflow run
     * @description Triggers a new generic workflow run.
     */
    post: operations['createWorkflowRun'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workflow-runs/{runName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get workflow run
     * @description Returns details of a specific workflow run.
     */
    get: operations['getWorkflowRun'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workflow-runs/{runName}/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get workflow run status
     * @description Returns the overall status and per-step status of a specific workflow run.
     */
    get: operations['getWorkflowRunStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workflow-runs/{runName}/logs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get workflow run logs
     * @description Returns logs for a specific workflow run from the build plane. Logs are fetched live from the build plane; no archived logs are returned for completed runs.
     */
    get: operations['getWorkflowRunLogs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workflow-runs/{runName}/events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get workflow run events
     * @description Returns Kubernetes events for a specific workflow run.
     */
    get: operations['getWorkflowRunEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/component-workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List component workflows
     * @description Returns a list of component workflow templates available in the namespace.
     */
    get: operations['listComponentWorkflows'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/component-workflows/{cwName}/schema': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get component workflow schema
     * @description Returns the parameter schema for a specific component workflow.
     */
    get: operations['getComponentWorkflowSchema'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/components/{componentName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get component
     * @description Returns details of a specific component.
     */
    get: operations['getComponent'];
    /**
     * Update component
     * @description Replaces an existing component (full update).
     */
    put: operations['updateComponent'];
    post?: never;
    /**
     * Delete component
     * @description Deletes a component by name.
     */
    delete: operations['deleteComponent'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/components/{componentName}/schema': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get component schema
     * @description Returns the combined parameter schema for a component (ComponentType + Traits).
     */
    get: operations['getComponentSchema'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/projects/{projectName}/components/{componentName}/environments/{environmentName}/release/resources': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get release resource tree
     * @description Returns all live Kubernetes resources deployed by the active release for a component in an environment, including child resources like Pods.
     */
    get: operations['getReleaseResourceTree'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/projects/{projectName}/components/{componentName}/environments/{environmentName}/release/resources/events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get resource events
     * @description Returns Kubernetes events for a specific resource in the release resource tree.
     */
    get: operations['getReleaseResourceEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/projects/{projectName}/components/{componentName}/environments/{environmentName}/release/resources/pod-logs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get pod logs
     * @description Returns logs for a specific pod in the release resource tree.
     */
    get: operations['getReleaseResourcePodLogs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/components/{componentName}/deploy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deploy release
     * @description Deploys a component release to an environment.
     */
    post: operations['deployRelease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/components/{componentName}/promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Promote component
     * @description Promotes a component release from one environment to another.
     */
    post: operations['promoteComponent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/components/{componentName}/generate-release': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate component release
     * @description Generates an immutable release snapshot from the current component state (ComponentType, Traits, Workload).
     */
    post: operations['generateRelease'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/projects/{projectName}/components/{componentName}/workflow-parameters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update component workflow parameters
     * @description Updates the workflow parameters for a component.
     */
    patch: operations['updateComponentWorkflowParameters'];
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/projects/{projectName}/components/{componentName}/workflow-runs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List component workflow runs
     * @description Returns a list of workflow runs for a component.
     */
    get: operations['listComponentWorkflowRuns'];
    put?: never;
    /**
     * Trigger component workflow run
     * @description Triggers a new workflow run (build) for a component.
     */
    post: operations['createComponentWorkflowRun'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/projects/{projectName}/components/{componentName}/workflow-runs/{runName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get component workflow run
     * @description Returns details of a specific workflow run.
     */
    get: operations['getComponentWorkflowRun'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/authz/actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List actions
     * @description Returns all defined authorization actions.
     */
    get: operations['listActions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/authz/evaluates': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Evaluate authorization
     * @description Evaluates one or more authorization requests in a single call.
     */
    post: operations['evaluates'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/authz/profile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get subject profile
     * @description Returns the authorization profile for the authenticated subject.
     */
    get: operations['getSubjectProfile'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterroles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List cluster roles
     * @description Returns all cluster-scoped authorization roles.
     */
    get: operations['listClusterRoles'];
    put?: never;
    /**
     * Create cluster role
     * @description Creates a new cluster-scoped authorization role.
     */
    post: operations['createClusterRole'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterroles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get cluster role
     * @description Returns details of a specific cluster role.
     */
    get: operations['getClusterRole'];
    /**
     * Update cluster role
     * @description Updates an existing cluster role's actions and description.
     */
    put: operations['updateClusterRole'];
    post?: never;
    /**
     * Delete cluster role
     * @description Deletes a cluster role.
     */
    delete: operations['deleteClusterRole'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterrolebindings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List cluster role bindings
     * @description Returns all cluster-scoped role bindings.
     */
    get: operations['listClusterRoleBindings'];
    put?: never;
    /**
     * Create cluster role binding
     * @description Creates a new cluster-scoped role binding.
     */
    post: operations['createClusterRoleBinding'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/clusterrolebindings/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get cluster role binding
     * @description Returns details of a specific cluster role binding.
     */
    get: operations['getClusterRoleBinding'];
    /**
     * Update cluster role binding
     * @description Updates an existing cluster role binding.
     */
    put: operations['updateClusterRoleBinding'];
    post?: never;
    /**
     * Delete cluster role binding
     * @description Deletes a cluster role binding.
     */
    delete: operations['deleteClusterRoleBinding'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List namespace roles
     * @description Returns all namespace-scoped authorization roles.
     */
    get: operations['listNamespaceRoles'];
    put?: never;
    /**
     * Create namespace role
     * @description Creates a new namespace-scoped authorization role.
     */
    post: operations['createNamespaceRole'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/roles/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get namespace role
     * @description Returns details of a specific namespace role.
     */
    get: operations['getNamespaceRole'];
    /**
     * Update namespace role
     * @description Updates an existing namespace role's actions and description.
     */
    put: operations['updateNamespaceRole'];
    post?: never;
    /**
     * Delete namespace role
     * @description Deletes a namespace role.
     */
    delete: operations['deleteNamespaceRole'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/rolebindings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List namespace role bindings
     * @description Returns all namespace-scoped role bindings.
     */
    get: operations['listNamespaceRoleBindings'];
    put?: never;
    /**
     * Create namespace role binding
     * @description Creates a new namespace-scoped role binding.
     */
    post: operations['createNamespaceRoleBinding'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/rolebindings/{name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get namespace role binding
     * @description Returns details of a specific namespace role binding.
     */
    get: operations['getNamespaceRoleBinding'];
    /**
     * Update namespace role binding
     * @description Updates an existing namespace role binding.
     */
    put: operations['updateNamespaceRoleBinding'];
    post?: never;
    /**
     * Delete namespace role binding
     * @description Deletes a namespace role binding.
     */
    delete: operations['deleteNamespaceRoleBinding'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/user-types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List user types
     * @description Returns the configured user types for authentication and authorization.
     */
    get: operations['listUserTypes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/webhooks/github': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Handle GitHub webhook
     * @description Processes incoming GitHub webhook events to trigger builds.
     */
    post: operations['handleGitHubWebhook'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/webhooks/gitlab': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Handle GitLab webhook
     * @description Processes incoming GitLab webhook events to trigger builds.
     */
    post: operations['handleGitLabWebhook'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/webhooks/bitbucket': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Handle Bitbucket webhook
     * @description Processes incoming Bitbucket webhook events to trigger builds.
     */
    post: operations['handleBitbucketWebhook'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/secretreferences': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List secret references
     * @description Returns a paginated list of secret references within a namespace.
     */
    get: operations['listSecretReferences'];
    put?: never;
    /**
     * Create secret reference
     * @description Creates a new secret reference within a namespace.
     */
    post: operations['createSecretReference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/secretreferences/{secretReferenceName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get secret reference
     * @description Returns details of a specific secret reference.
     */
    get: operations['getSecretReference'];
    /**
     * Update secret reference
     * @description Replaces an existing secret reference (full update).
     */
    put: operations['updateSecretReference'];
    post?: never;
    /**
     * Delete secret reference
     * @description Deletes a secret reference by name.
     */
    delete: operations['deleteSecretReference'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workloads': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List workloads
     * @description Returns a paginated list of workloads within a namespace, optionally filtered by component.
     */
    get: operations['listWorkloads'];
    put?: never;
    /**
     * Create workload
     * @description Creates a new workload within a namespace.
     */
    post: operations['createWorkload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/workloads/{workloadName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get workload
     * @description Returns details of a specific workload.
     */
    get: operations['getWorkload'];
    /**
     * Update workload
     * @description Replaces an existing workload (full update).
     */
    put: operations['updateWorkload'];
    post?: never;
    /**
     * Delete workload
     * @description Deletes a workload by name.
     */
    delete: operations['deleteWorkload'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/componentreleases': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List component releases
     * @description Returns a paginated list of component releases within a namespace, optionally filtered by component.
     */
    get: operations['listComponentReleases'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/componentreleases/{componentReleaseName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get component release
     * @description Returns details of a specific component release.
     */
    get: operations['getComponentRelease'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/releases': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List releases
     * @description Returns a paginated list of releases within a namespace, optionally filtered by component and environment.
     */
    get: operations['listReleases'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/releases/{releaseName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get release
     * @description Returns details of a specific release.
     */
    get: operations['getRelease'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/releasebindings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List release bindings
     * @description Returns a paginated list of release bindings within a namespace, optionally filtered by component.
     */
    get: operations['listReleaseBindings'];
    put?: never;
    /**
     * Create release binding
     * @description Creates a new release binding within a namespace.
     */
    post: operations['createReleaseBinding'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/releasebindings/{releaseBindingName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get release binding
     * @description Returns details of a specific release binding.
     */
    get: operations['getReleaseBinding'];
    /**
     * Update release binding
     * @description Replaces an existing release binding (full update).
     */
    put: operations['updateReleaseBinding'];
    post?: never;
    /**
     * Delete release binding
     * @description Deletes a release binding by name.
     */
    delete: operations['deleteReleaseBinding'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/deploymentpipelines': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List deployment pipelines
     * @description Returns a paginated list of deployment pipelines within a namespace.
     */
    get: operations['listDeploymentPipelines'];
    put?: never;
    /**
     * Create deployment pipeline
     * @description Creates a new deployment pipeline within a namespace.
     */
    post: operations['createDeploymentPipeline'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/deploymentpipelines/{deploymentPipelineName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get deployment pipeline
     * @description Returns details of a specific deployment pipeline.
     */
    get: operations['getDeploymentPipeline'];
    /**
     * Update deployment pipeline
     * @description Replaces an existing deployment pipeline (full update).
     */
    put: operations['updateDeploymentPipeline'];
    post?: never;
    /**
     * Delete deployment pipeline
     * @description Deletes a deployment pipeline by name.
     */
    delete: operations['deleteDeploymentPipeline'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/observabilityalertsnotificationchannels': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List observability alerts notification channels
     * @description Returns a paginated list of observability alerts notification channels within a namespace.
     */
    get: operations['listObservabilityAlertsNotificationChannels'];
    put?: never;
    /**
     * Create observability alerts notification channel
     * @description Creates a new observability alerts notification channel within a namespace.
     */
    post: operations['createObservabilityAlertsNotificationChannel'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespaceName}/observabilityalertsnotificationchannels/{observabilityAlertsNotificationChannelName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get observability alerts notification channel
     * @description Returns details of a specific observability alerts notification channel.
     */
    get: operations['getObservabilityAlertsNotificationChannel'];
    /**
     * Update observability alerts notification channel
     * @description Replaces an existing observability alerts notification channel (full update).
     */
    put: operations['updateObservabilityAlertsNotificationChannel'];
    post?: never;
    /**
     * Delete observability alerts notification channel
     * @description Deletes an observability alerts notification channel by name.
     */
    delete: operations['deleteObservabilityAlertsNotificationChannel'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1alpha1/namespaces/{namespaceName}/gitsecrets': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List git secrets
     * @description Returns all git secrets in a namespace.
     */
    get: operations['listGitSecrets'];
    put?: never;
    /**
     * Create a git secret
     * @description Creates a new git secret for source code authentication.
     */
    post: operations['createGitSecret'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1alpha1/namespaces/{namespaceName}/gitsecrets/{gitSecretName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete a git secret
     * @description Deletes a git secret by name.
     */
    delete: operations['deleteGitSecret'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Standard error response format */
    ErrorResponse: {
      /**
       * @description Human-readable error message
       * @example Project 'my-project' not found
       */
      error: string;
      /**
       * @description Machine-readable error code
       * @example NOT_FOUND
       * @enum {string}
       */
      code:
        | 'BAD_REQUEST'
        | 'UNAUTHORIZED'
        | 'FORBIDDEN'
        | 'NOT_FOUND'
        | 'CONFLICT'
        | 'INTERNAL_ERROR';
      /** @description Additional error details (e.g., validation errors) */
      details?: {
        /**
         * @description Field that caused the error
         * @example name
         */
        field?: string;
        /**
         * @description Error message for this field
         * @example must be at least 1 character
         */
        message?: string;
      }[];
    };
    /**
     * @description Standard Kubernetes object metadata (without kind/apiVersion).
     *     Matches the structure of metav1.ObjectMeta for the fields exposed via the API.
     */
    ObjectMeta: {
      /**
       * @description Name of the resource (unique within namespace)
       * @example my-project
       */
      name: string;
      /**
       * @description Kubernetes namespace
       * @example my-namespace
       */
      namespace?: string;
      /**
       * @description Unique identifier (Kubernetes UID)
       * @example 550e8400-e29b-41d4-a716-446655440000
       */
      uid?: string;
      /** @description Map of string keys and values for organizing resources */
      labels?: {
        [key: string]: string;
      };
      /** @description Map of string keys and values for storing auxiliary data */
      annotations?: {
        [key: string]: string;
      };
      /**
       * Format: date-time
       * @description Creation timestamp
       * @example 2025-01-06T10:00:00Z
       */
      creationTimestamp?: string;
    };
    /** @description Kubernetes-style condition */
    Condition: {
      /**
       * @description Type of condition (e.g., Ready)
       * @example Ready
       */
      type: string;
      /**
       * @description Status of the condition
       * @example True
       * @enum {string}
       */
      status: 'True' | 'False' | 'Unknown';
      /**
       * Format: int64
       * @description Generation observed when this condition was set
       */
      observedGeneration?: number;
      /**
       * Format: date-time
       * @description Last time the condition transitioned
       * @example 2025-01-06T10:00:05Z
       */
      lastTransitionTime: string;
      /**
       * @description Machine-readable reason for the condition
       * @example Reconciled
       */
      reason: string;
      /**
       * @description Human-readable message
       * @example Project is ready
       */
      message?: string;
    };
    /** @description Server version information */
    VersionResponse: {
      /**
       * @description Application name
       * @example openchoreo-api
       */
      name: string;
      /**
       * @description Version string
       * @example v0.1.0
       */
      version: string;
      /**
       * @description Git commit SHA
       * @example abc1234
       */
      gitRevision: string;
      /**
       * @description Build timestamp
       * @example 2025-01-06T10:00:00Z
       */
      buildTime: string;
      /**
       * @description Target operating system
       * @example linux
       */
      goOS: string;
      /**
       * @description Target architecture
       * @example amd64
       */
      goArch: string;
      /**
       * @description Go version used to build
       * @example go1.24.2
       */
      goVersion: string;
    };
    /** @description OAuth 2.0 protected resource metadata as defined in RFC 9728 */
    OAuthProtectedResourceMetadata: {
      /**
       * @description Human-readable name of the protected resource
       * @example OpenChoreo MCP Server
       */
      resource_name: string;
      /**
       * @description URL of the protected resource
       * @example https://api.openchoreo.dev/mcp
       */
      resource: string;
      /**
       * @description List of authorization server URLs
       * @example [
       *       "https://auth.openchoreo.dev"
       *     ]
       */
      authorization_servers: string[];
      /**
       * @description Supported bearer token methods
       * @example [
       *       "header"
       *     ]
       */
      bearer_methods_supported: string[];
      /** @description Supported OAuth scopes */
      scopes_supported: string[];
      /**
       * @description OpenChoreo extension (RFC 9728 ยง2). OAuth client configurations for
       *     external integrations (e.g., CLI). Used by clients to discover their
       *     client_id and required scopes.
       */
      openchoreo_clients?: components['schemas']['OpenChoreoClient'][];
      /**
       * @description OpenChoreo extension (RFC 9728 ยง2). Indicates whether authentication
       *     is enforced on this server. When false, requests without tokens are
       *     accepted.
       * @example true
       */
      openchoreo_security_enabled?: boolean;
    };
    /** @description OAuth client configuration for an OpenChoreo external integration (e.g., CLI) */
    OpenChoreoClient: {
      /**
       * @description Name of the client integration
       * @example cli
       */
      name: string;
      /**
       * @description OAuth2 client ID
       * @example openchoreo-cli
       */
      client_id: string;
      /**
       * @description OAuth2 scopes required by this client
       * @example [
       *       "openid",
       *       "profile",
       *       "email"
       *     ]
       */
      scopes: string[];
    };
    /** @description Configuration for a user type used in authentication and authorization */
    UserTypeConfig: {
      /**
       * @description User type identifier (e.g., "user", "service_account")
       * @example user
       */
      type: string;
      /**
       * @description Human-readable name for the user type
       * @example Human User
       */
      displayName: string;
      /**
       * @description Check order for user type detection (lower = higher priority)
       * @example 1
       */
      priority: number;
      /** @description Supported authentication mechanisms for this user type */
      authMechanisms: components['schemas']['AuthMechanismConfig'][];
    };
    /** @description Configuration for an authentication mechanism */
    AuthMechanismConfig: {
      /**
       * @description Authentication mechanism type (e.g., "jwt", "oauth2", "api_key")
       * @example jwt
       */
      type: string;
      entitlement: components['schemas']['EntitlementConfig'];
    };
    /** @description Configuration for extracting entitlement claims from tokens */
    EntitlementConfig: {
      /**
       * @description Claim name for detection and entitlement (e.g., "groups", "scopes")
       * @example groups
       */
      claim: string;
      /**
       * @description Human-readable name for the claim
       * @example Groups
       */
      displayName: string;
    };
    /**
     * @description Cursor-based pagination metadata. Uses Kubernetes-native continuation tokens
     *     for efficient pagination through large result sets.
     */
    Pagination: {
      /**
       * @description Opaque cursor for fetching the next page. Pass this value as the
       *     `cursor` query parameter in the next request. Absent when there
       *     are no more items.
       * @example eyJ2IjoibWV0YS5rOHMuaW8vdjEiLCJydiI6MzQ0N30=
       */
      nextCursor?: string;
      /**
       * Format: int64
       * @description Approximate number of items remaining after this page.
       *     This is an estimate provided by Kubernetes and may not be exact.
       *     Use for UI hints like "~50 more items". May be absent for
       *     filtered queries.
       * @example 42
       */
      remainingCount?: number;
    };
    /** @description Paginated list of namespaces */
    NamespaceList: {
      items: components['schemas']['Namespace'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description Namespace resource (Kubernetes object without kind/apiVersion).
     *     Control plane namespaces hold resources like Projects, Components, and Environments.
     *     These namespaces are identified by the label `openchoreo.dev/controlplane-namespace=true`.
     */
    Namespace: {
      metadata: components['schemas']['ObjectMeta'];
      readonly status?: components['schemas']['NamespaceStatus'];
    };
    /** @description Observed state of a Namespace */
    NamespaceStatus: {
      /**
       * @description Namespace phase
       * @example Active
       * @enum {string}
       */
      phase?: 'Active' | 'Terminating';
    };
    /** @description Reference to a BuildPlane or ClusterBuildPlane */
    BuildPlaneRef: {
      /**
       * @description Kind of build plane
       * @example BuildPlane
       * @enum {string}
       */
      kind: 'BuildPlane' | 'ClusterBuildPlane';
      /**
       * @description Name of the build plane resource
       * @example default
       */
      name: string;
    };
    /** @description Desired state of a Project */
    ProjectSpec: {
      /**
       * @description Reference to the DeploymentPipeline that defines the environments
       *     and deployment progression for components in this project.
       * @example default
       */
      deploymentPipelineRef?: string;
      buildPlaneRef?: components['schemas']['BuildPlaneRef'];
    };
    /** @description Observed state of a Project */
    ProjectStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed Project
       */
      observedGeneration?: number;
      /** @description Current state conditions of the Project */
      conditions?: components['schemas']['Condition'][];
    };
    /**
     * @description Project resource (Kubernetes object without kind/apiVersion).
     *     Projects group components within a namespace and reference a deployment pipeline.
     */
    Project: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ProjectSpec'];
      readonly status?: components['schemas']['ProjectStatus'];
    };
    /** @description Paginated list of projects */
    ProjectList: {
      items: components['schemas']['Project'][];
      pagination?: components['schemas']['Pagination'];
    };
    /** @description Paginated list of components */
    ComponentList: {
      items: components['schemas']['Component'][];
      pagination?: components['schemas']['Pagination'];
    };
    /** @description Desired state of a Component */
    ComponentSpec: {
      /** @description Ownership information for the component */
      owner: {
        /**
         * @description Name of the project this component belongs to
         * @example my-project
         */
        projectName: string;
      };
      /** @description Reference to the ComponentType or ClusterComponentType */
      componentType: {
        /**
         * @description Kind of component type (ComponentType or ClusterComponentType)
         * @default ComponentType
         * @enum {string}
         */
        kind: 'ComponentType' | 'ClusterComponentType';
        /**
         * @description Component type reference in format: {workloadType}/{componentTypeName}
         * @example deployment/go-service
         */
        name: string;
      };
      /**
       * @description Whether to automatically deploy to default environment when created
       * @default false
       * @example true
       */
      autoDeploy: boolean;
      /**
       * @description Whether to automatically trigger builds on code push
       * @example false
       */
      autoBuild?: boolean;
      /** @description ComponentType parameter values (schema defined by the referenced ComponentType) */
      parameters?: {
        [key: string]: unknown;
      };
      /** @description Trait instances attached to the component */
      traits?: components['schemas']['ComponentTrait'][];
      workflow?: components['schemas']['ComponentWorkflowConfig'];
    };
    /** @description Observed state of a Component */
    ComponentStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed Component
       */
      observedGeneration?: number;
      /** @description Current state conditions of the Component */
      conditions?: components['schemas']['Condition'][];
      /** @description Information about the latest ComponentRelease created for this component */
      latestRelease?: {
        /**
         * @description Name of the latest ComponentRelease resource
         * @example my-component-abc123
         */
        name?: string;
        /**
         * @description Hash of the latest ComponentRelease spec
         * @example sha256:abc123
         */
        releaseHash?: string;
      };
    };
    /**
     * @description Component resource (Kubernetes object without kind/apiVersion).
     *     Components group source code and deployment configuration within a project.
     */
    Component: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ComponentSpec'];
      readonly status?: components['schemas']['ComponentStatus'];
    };
    /** @description Component workflow configuration */
    ComponentWorkflowConfig: {
      /**
       * @description Workflow name
       * @example docker-build
       */
      name?: string;
      /** @description System-managed parameters (repository info) */
      systemParameters?: {
        repository?: {
          /**
           * @description Git repository URL
           * @example https://github.com/org/repo.git
           */
          url?: string;
          revision?: {
            /**
             * @description Git branch
             * @example main
             */
            branch?: string;
            /**
             * @description Git commit SHA
             * @example abc1234
             */
            commit?: string;
          };
          /**
           * @description Path to application within repository
           * @example ./services/api
           */
          appPath?: string;
        };
      };
      /** @description User-defined workflow parameters */
      parameters?: {
        [key: string]: unknown;
      };
    };
    /** @description Request to create a new component */
    CreateComponentRequest: {
      /**
       * @description Component name (must be unique within project)
       * @example api-service
       */
      name: string;
      /**
       * @description Human-readable display name
       * @example API Service
       */
      displayName?: string;
      /**
       * @description Component description
       * @example Main REST API service
       */
      description?: string;
      /**
       * @deprecated
       * @description DEPRECATED: Use componentType instead. Legacy component type field.
       * @example service/go-service
       */
      type?: string;
      /**
       * @description Component type reference (format: {workloadType}/{componentTypeName})
       * @example service/go-service
       */
      componentType?: string;
      /**
       * @description Whether to automatically deploy to default environment
       * @default false
       * @example true
       */
      autoDeploy: boolean;
      /** @description Component type parameters */
      parameters?: {
        [key: string]: unknown;
      };
      /** @description Trait instances to attach to the component */
      traits?: components['schemas']['ComponentTraitInput'][];
      workflow?: components['schemas']['ComponentWorkflowInput'];
    };
    /** @description Trait instance to attach to a component */
    ComponentTraitInput: {
      /**
       * @description Kind of trait resource (Trait for namespace-scoped, ClusterTrait for cluster-scoped)
       * @default Trait
       * @example Trait
       * @enum {string}
       */
      kind: 'Trait' | 'ClusterTrait';
      /**
       * @description Trait resource name
       * @example autoscaler
       */
      name: string;
      /**
       * @description Unique instance name within the component
       * @example api-autoscaler
       */
      instanceName: string;
      /** @description Trait parameter values */
      parameters?: {
        [key: string]: unknown;
      };
    };
    /** @description Workflow configuration for component creation */
    ComponentWorkflowInput: {
      /**
       * @description ComponentWorkflow resource name
       * @example docker-build
       */
      name: string;
      /** @description System parameters including repository configuration */
      systemParameters: {
        repository: {
          /**
           * @description Git repository URL
           * @example https://github.com/org/repo.git
           */
          url: string;
          revision: {
            /**
             * @description Git branch to build from
             * @example main
             */
            branch: string;
            /**
             * @description Specific commit SHA (optional)
             * @example abc1234
             */
            commit?: string;
          };
          /**
           * @description Path to application within repository
           * @example ./services/api
           */
          appPath: string;
        };
      };
      /** @description User-defined workflow parameters */
      parameters?: {
        [key: string]: unknown;
      };
    };
    /** @description Desired state of an Environment */
    EnvironmentSpec: {
      /**
       * @description Reference to the DataPlane or ClusterDataPlane for this environment.
       *     If not specified, defaults to a DataPlane named "default" in the same namespace.
       *     Immutable once set.
       */
      dataPlaneRef?: {
        /**
         * @description Kind of data plane (DataPlane or ClusterDataPlane)
         * @example DataPlane
         * @enum {string}
         */
        kind: 'DataPlane' | 'ClusterDataPlane';
        /**
         * @description Name of the data plane resource
         * @example default
         */
        name: string;
      };
      /**
       * @description Whether this is a production environment
       * @example false
       */
      isProduction?: boolean;
      /** @description Gateway configuration for the environment */
      gateway?: {
        /** @description Public virtual host for the gateway */
        publicVirtualHost?: string;
        /** @description Organization-specific virtual host for the gateway */
        organizationVirtualHost?: string;
      };
    };
    /** @description Observed state of an Environment */
    EnvironmentStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed Environment
       */
      observedGeneration?: number;
      /** @description Current state conditions of the Environment */
      conditions?: components['schemas']['Condition'][];
    };
    /**
     * @description Environment resource (Kubernetes object without kind/apiVersion).
     *     Environments represent deployment targets within a namespace.
     */
    Environment: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['EnvironmentSpec'];
      readonly status?: components['schemas']['EnvironmentStatus'];
    };
    /** @description Paginated list of environments */
    EnvironmentList: {
      items: components['schemas']['Environment'][];
      pagination?: components['schemas']['Pagination'];
    };
    /** @description Observer URL response for accessing logs and metrics */
    ObserverURLResponse: {
      /**
       * @description URL to the observer service for logs and metrics
       * @example https://observer.example.com/api/v1
       */
      observerUrl?: string;
      /**
       * @description Additional information or status message
       * @example Observer URL is available
       */
      message?: string;
    };
    /** @description RCA agent URL response for AI-powered root cause analysis */
    RCAAgentURLResponse: {
      /**
       * @description URL to the RCA agent service for AI-powered root cause analysis
       * @example https://rca-agent.example.com
       */
      rcaAgentUrl?: string;
      /**
       * @description Additional information or status message
       * @example RCA agent URL is available
       */
      message?: string;
    };
    /** @description Paginated list of data planes */
    DataPlaneList: {
      items: components['schemas']['DataPlane'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description DataPlane resource (Kubernetes object without kind/apiVersion).
     *     Represents a Kubernetes cluster for workload deployment.
     */
    DataPlane: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['DataPlaneSpec'];
      readonly status?: components['schemas']['DataPlaneStatus'];
    };
    /** @description Desired state of a DataPlane */
    DataPlaneSpec: {
      /**
       * @description Logical plane identifier for the physical cluster.
       *     Multiple DataPlane CRs can share the same planeID.
       * @example prod-cluster
       */
      planeID?: string;
      clusterAgent?: components['schemas']['ClusterAgentConfig'];
      gateway?: components['schemas']['GatewaySpec'];
      /**
       * @description References to SecretReference resources for image pulling
       * @example [
       *       "docker-registry-secret"
       *     ]
       */
      imagePullSecretRefs?: string[];
      secretStoreRef?: components['schemas']['SecretStoreRef'];
      observabilityPlaneRef?: components['schemas']['ObservabilityPlaneRef'];
    };
    /** @description Observed state of a DataPlane */
    DataPlaneStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed DataPlane
       */
      observedGeneration?: number;
      /** @description Current state conditions of the DataPlane */
      conditions?: components['schemas']['Condition'][];
      agentConnection?: components['schemas']['AgentConnectionStatus'];
    };
    /** @description Gateway configuration for a data plane */
    GatewaySpec: {
      /**
       * @description Public virtual host for external traffic
       * @example apps.example.com
       */
      publicVirtualHost?: string;
      /**
       * @description Organization-specific virtual host
       * @example internal.example.com
       */
      organizationVirtualHost?: string;
      /**
       * Format: int32
       * @description Public HTTP port
       * @example 19080
       */
      publicHTTPPort?: number;
      /**
       * Format: int32
       * @description Public HTTPS port
       * @example 19443
       */
      publicHTTPSPort?: number;
      /**
       * Format: int32
       * @description Organization HTTP port
       * @example 19081
       */
      organizationHTTPPort?: number;
      /**
       * Format: int32
       * @description Organization HTTPS port
       * @example 19444
       */
      organizationHTTPSPort?: number;
      /**
       * @description Name of the public Gateway resource
       * @example gateway-default
       */
      publicGatewayName?: string;
      /**
       * @description Namespace of the public Gateway resource
       * @example openchoreo-data-plane
       */
      publicGatewayNamespace?: string;
      /**
       * @description Name of the organization Gateway resource
       * @example gateway-default
       */
      organizationGatewayName?: string;
      /**
       * @description Namespace of the organization Gateway resource
       * @example openchoreo-data-plane
       */
      organizationGatewayNamespace?: string;
    };
    /** @description Paginated list of build planes */
    BuildPlaneList: {
      items: components['schemas']['BuildPlane'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description BuildPlane resource (Kubernetes object without kind/apiVersion).
     *     Represents CI/CD build infrastructure within a namespace.
     */
    BuildPlane: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['BuildPlaneSpec'];
      readonly status?: components['schemas']['BuildPlaneStatus'];
    };
    /** @description Desired state of a BuildPlane */
    BuildPlaneSpec: {
      /**
       * @description Logical plane identifier for the physical cluster.
       *     Multiple BuildPlane CRs can share the same planeID.
       * @example ci-cluster
       */
      planeID?: string;
      clusterAgent?: components['schemas']['ClusterAgentConfig'];
      secretStoreRef?: components['schemas']['SecretStoreRef'];
      observabilityPlaneRef?: components['schemas']['ObservabilityPlaneRef'];
    };
    /** @description Observed state of a BuildPlane */
    BuildPlaneStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed BuildPlane
       */
      observedGeneration?: number;
      /** @description Current state conditions of the BuildPlane */
      conditions?: components['schemas']['Condition'][];
      agentConnection?: components['schemas']['AgentConnectionStatus'];
    };
    /** @description Configuration for cluster agent-based communication */
    ClusterAgentConfig: {
      clientCA?: components['schemas']['ValueFrom'];
    };
    /** @description Reference to a secret or inline value */
    ValueFrom: {
      secretRef?: components['schemas']['SecretKeyReference'];
      /** @description Inline value (optional fallback) */
      value?: string;
    };
    /** @description Reference to a specific key in a Kubernetes secret */
    SecretKeyReference: {
      /** @description Name of the secret */
      name?: string;
      /** @description Namespace of the secret */
      namespace?: string;
      /** @description Key within the secret */
      key?: string;
    };
    /** @description Reference to an External Secrets Operator ClusterSecretStore */
    SecretStoreRef: {
      /** @description Name of the ClusterSecretStore resource */
      name?: string;
    };
    /** @description Status of cluster agent connections */
    AgentConnectionStatus: {
      /** @description Whether any cluster agent is currently connected */
      connected?: boolean;
      /** @description Number of cluster agents currently connected */
      connectedAgents?: number;
      /**
       * Format: date-time
       * @description When an agent last successfully connected
       */
      lastConnectedTime?: string;
      /**
       * Format: date-time
       * @description When the last agent disconnected
       */
      lastDisconnectedTime?: string;
      /**
       * Format: date-time
       * @description When control plane last received communication from an agent
       */
      lastHeartbeatTime?: string;
      /** @description Additional information about agent connection status */
      message?: string;
    };
    /** @description Reference to an ObservabilityPlane or ClusterObservabilityPlane */
    ObservabilityPlaneRef: {
      /**
       * @description Kind of observability plane (ObservabilityPlane or ClusterObservabilityPlane)
       * @example ObservabilityPlane
       * @enum {string}
       */
      kind: 'ObservabilityPlane' | 'ClusterObservabilityPlane';
      /**
       * @description Name of the observability plane resource. Must be a valid DNS-1123 label.
       * @example default
       */
      name: string;
    };
    /** @description Paginated list of observability planes */
    ObservabilityPlaneList: {
      items: components['schemas']['ObservabilityPlane'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description ObservabilityPlane resource (Kubernetes object without kind/apiVersion).
     *     Represents monitoring and logging infrastructure within a namespace.
     */
    ObservabilityPlane: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ObservabilityPlaneSpec'];
      readonly status?: components['schemas']['ObservabilityPlaneStatus'];
    };
    /** @description Desired state of an ObservabilityPlane */
    ObservabilityPlaneSpec: {
      /**
       * @description Logical plane identifier for the physical cluster.
       *     Multiple ObservabilityPlane CRs can share the same planeID.
       * @example shared-obs
       */
      planeID?: string;
      clusterAgent?: components['schemas']['ClusterAgentConfig'];
      /**
       * @description Base URL of the Observer API in the observability plane cluster
       * @example http://observer.observability-plane.svc:8080
       */
      observerURL?: string;
      /**
       * @description Base URL of the RCA Agent API in the observability plane cluster
       * @example http://rca-agent.observability-plane.svc:8080
       */
      rcaAgentURL?: string;
    };
    /** @description Observed state of an ObservabilityPlane */
    ObservabilityPlaneStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed ObservabilityPlane
       */
      observedGeneration?: number;
      /** @description Current state conditions of the ObservabilityPlane */
      conditions?: components['schemas']['Condition'][];
      agentConnection?: components['schemas']['AgentConnectionStatus'];
    };
    /** @description Paginated list of cluster-scoped data planes */
    ClusterDataPlaneList: {
      items: components['schemas']['ClusterDataPlane'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description ClusterDataPlane resource (Kubernetes object without kind/apiVersion).
     *     Represents a cluster-scoped data plane for workload deployment.
     */
    ClusterDataPlane: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ClusterDataPlaneSpec'];
      readonly status?: components['schemas']['ClusterDataPlaneStatus'];
    };
    /** @description Desired state of a ClusterDataPlane */
    ClusterDataPlaneSpec: {
      /**
       * @description Logical plane identifier for the physical cluster.
       *     Multiple ClusterDataPlane CRs can share the same planeID.
       * @example us-west-prod-cluster
       */
      planeID?: string;
      clusterAgent?: components['schemas']['ClusterAgentConfig'];
      gateway?: components['schemas']['GatewaySpec'];
      /**
       * @description References to SecretReference resources for image pulling
       * @example [
       *       "docker-registry-secret"
       *     ]
       */
      imagePullSecretRefs?: string[];
      secretStoreRef?: components['schemas']['SecretStoreRef'];
      observabilityPlaneRef?: components['schemas']['ClusterObservabilityPlaneRef'];
    };
    /** @description Observed state of a ClusterDataPlane */
    ClusterDataPlaneStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed ClusterDataPlane
       */
      observedGeneration?: number;
      /** @description Current state conditions of the ClusterDataPlane */
      conditions?: components['schemas']['Condition'][];
      agentConnection?: components['schemas']['AgentConnectionStatus'];
    };
    /** @description List of cluster-scoped build planes */
    ClusterBuildPlaneList: {
      items: components['schemas']['ClusterBuildPlane'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description ClusterBuildPlane resource (Kubernetes object without kind/apiVersion).
     *     Represents cluster-scoped CI/CD build infrastructure.
     */
    ClusterBuildPlane: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ClusterBuildPlaneSpec'];
      readonly status?: components['schemas']['ClusterBuildPlaneStatus'];
    };
    /** @description Desired state of a ClusterBuildPlane */
    ClusterBuildPlaneSpec: {
      /**
       * @description Logical plane identifier for the physical cluster.
       *     Multiple ClusterBuildPlane CRs can share the same planeID.
       * @example ci-cluster
       */
      planeID?: string;
      clusterAgent?: components['schemas']['ClusterAgentConfig'];
      secretStoreRef?: components['schemas']['SecretStoreRef'];
      observabilityPlaneRef?: components['schemas']['ClusterObservabilityPlaneRef'];
    };
    /** @description Observed state of a ClusterBuildPlane */
    ClusterBuildPlaneStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed ClusterBuildPlane
       */
      observedGeneration?: number;
      /** @description Current state conditions of the ClusterBuildPlane */
      conditions?: components['schemas']['Condition'][];
      agentConnection?: components['schemas']['AgentConnectionStatus'];
    };
    /** @description Reference to a ClusterObservabilityPlane (cluster-scoped only) */
    ClusterObservabilityPlaneRef: {
      /**
       * @description Kind of observability plane (only ClusterObservabilityPlane allowed)
       * @example ClusterObservabilityPlane
       * @enum {string}
       */
      kind: 'ClusterObservabilityPlane';
      /**
       * @description Name of the ClusterObservabilityPlane resource
       * @example default
       */
      name: string;
    };
    /** @description List of cluster-scoped observability planes */
    ClusterObservabilityPlaneList: {
      items: components['schemas']['ClusterObservabilityPlane'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description ClusterObservabilityPlane resource (Kubernetes object without kind/apiVersion).
     *     Represents cluster-scoped monitoring and logging infrastructure.
     */
    ClusterObservabilityPlane: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ClusterObservabilityPlaneSpec'];
      readonly status?: components['schemas']['ClusterObservabilityPlaneStatus'];
    };
    /** @description Desired state of a ClusterObservabilityPlane */
    ClusterObservabilityPlaneSpec: {
      /**
       * @description Logical plane identifier for the physical cluster.
       *     Multiple ClusterObservabilityPlane CRs can share the same planeID.
       * @example monitoring-cluster
       */
      planeID?: string;
      clusterAgent?: components['schemas']['ClusterAgentConfig'];
      /**
       * @description Base URL of the Observer API in the observability plane cluster
       * @example http://observer.observability-plane.svc:8080
       */
      observerURL?: string;
      /**
       * @description Base URL of the RCA Agent API in the observability plane cluster
       * @example http://rca-agent.observability-plane.svc:8080
       */
      rcaAgentURL?: string;
    };
    /** @description Observed state of a ClusterObservabilityPlane */
    ClusterObservabilityPlaneStatus: {
      /**
       * Format: int64
       * @description Generation of the most recently observed ClusterObservabilityPlane
       */
      observedGeneration?: number;
      /** @description Current state conditions of the ClusterObservabilityPlane */
      conditions?: components['schemas']['Condition'][];
      agentConnection?: components['schemas']['AgentConnectionStatus'];
    };
    /** @description Paginated list of cluster-scoped component types */
    ClusterComponentTypeList: {
      items: components['schemas']['ClusterComponentType'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description ClusterComponentType resource (Kubernetes object without kind/apiVersion).
     *     Cluster-scoped version of ComponentType.
     */
    ClusterComponentType: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ClusterComponentTypeSpec'];
      readonly status?: components['schemas']['ClusterComponentTypeStatus'];
    };
    /** @description Desired state of a ClusterComponentType */
    ClusterComponentTypeSpec: {
      /**
       * @description Primary workload resource type for this component type
       * @example deployment
       * @enum {string}
       */
      workloadType: 'deployment' | 'statefulset' | 'cronjob' | 'job' | 'proxy';
      /**
       * @description List of allowed ComponentWorkflow names for this component type
       * @example [
       *       "docker-build",
       *       "buildpack-build"
       *     ]
       */
      allowedWorkflows?: string[];
      /** @description Developer-configurable schema definition */
      schema?: {
        /** @description Reusable type definitions */
        types?: {
          [key: string]: unknown;
        };
        /** @description Static developer configuration parameters */
        parameters?: {
          [key: string]: unknown;
        };
        /** @description Environment-specific overrides for platform engineers */
        envOverrides?: {
          [key: string]: unknown;
        };
      };
      /** @description Pre-configured trait instances embedded in this component type */
      traits?: {
        /**
         * @description Kind of trait (only ClusterTrait allowed for cluster-scoped)
         * @default ClusterTrait
         * @enum {string}
         */
        kind: 'ClusterTrait';
        /** @description Name of the ClusterTrait resource */
        name: string;
        /** @description Unique instance name for this trait */
        instanceName: string;
        /** @description Trait parameter bindings (concrete values or CEL expressions) */
        parameters?: {
          [key: string]: unknown;
        };
        /** @description Trait environment override bindings */
        envOverrides?: {
          [key: string]: unknown;
        };
      }[];
      /** @description Restricts which ClusterTrait CRs developers can attach to Components of this type. Each entry is an object with "kind" (always ClusterTrait) and "name" referencing a ClusterTrait. If empty or omitted, no additional component-level traits are permitted (only embedded traits defined in spec.traits are allowed). */
      allowedTraits?: {
        /**
         * @description Kind of trait reference (must be ClusterTrait)
         * @enum {string}
         */
        kind: 'ClusterTrait';
        /** @description Name of the ClusterTrait resource */
        name: string;
      }[];
      /** @description CEL-based validation rules evaluated during rendering */
      validations?: {
        /** @description CEL expression wrapped in ${...} that must evaluate to true */
        rule: string;
        /** @description Error message shown when the rule evaluates to false */
        message: string;
      }[];
      /** @description Templates that generate Kubernetes resources dynamically */
      resources: {
        /** @description Unique identifier for this resource within the component type */
        id: string;
        /**
         * @description Target plane for deployment
         * @default dataplane
         * @enum {string}
         */
        targetPlane: 'dataplane' | 'observabilityplane';
        /** @description CEL expression determining if this resource should be created */
        includeWhen?: string;
        /** @description CEL expression for generating multiple resources from a list */
        forEach?: string;
        /** @description Loop variable name when using forEach */
        var?: string;
        /** @description Kubernetes resource template with CEL expressions */
        template: {
          [key: string]: unknown;
        };
      }[];
    };
    /** @description Observed state of a ClusterComponentType */
    ClusterComponentTypeStatus: Record<string, never>;
    /** @description Paginated list of cluster-scoped traits */
    ClusterTraitList: {
      items: components['schemas']['ClusterTrait'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description ClusterTrait resource (Kubernetes object without kind/apiVersion).
     *     Cluster-scoped version of Trait.
     */
    ClusterTrait: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ClusterTraitSpec'];
      readonly status?: components['schemas']['ClusterTraitStatus'];
    };
    /** @description Desired state of a ClusterTrait */
    ClusterTraitSpec: {
      /** @description Trait parameter schema definition */
      schema?: {
        /** @description Reusable type definitions */
        types?: {
          [key: string]: unknown;
        };
        /** @description Developer-facing configuration options */
        parameters?: {
          [key: string]: unknown;
        };
        /** @description Environment-specific overrides */
        envOverrides?: {
          [key: string]: unknown;
        };
      };
      /** @description New Kubernetes resources to create when this trait is applied */
      creates?: {
        /**
         * @description Target plane for deployment
         * @default dataplane
         * @enum {string}
         */
        targetPlane: 'dataplane' | 'observabilityplane';
        /** @description CEL expression determining if this resource should be created */
        includeWhen?: string;
        /** @description CEL expression for generating multiple resources from a list */
        forEach?: string;
        /** @description Loop variable name when using forEach */
        var?: string;
        /** @description Kubernetes resource template with CEL expressions */
        template: {
          [key: string]: unknown;
        };
      }[];
      /** @description Modifications to existing resources generated by the ComponentType */
      patches?: {
        /** @description CEL expression for repeating this patch */
        forEach?: string;
        /** @description Loop variable name when using forEach */
        var?: string;
        /** @description Target resource to patch */
        target: {
          /** @description API group of the resource */
          group: string;
          /** @description API version of the resource */
          version: string;
          /** @description Resource type to patch */
          kind: string;
          /** @description CEL expression to filter which resources to patch */
          where?: string;
        };
        /**
         * @description Target plane for this patch
         * @default dataplane
         * @enum {string}
         */
        targetPlane: 'dataplane' | 'observabilityplane';
        /** @description JSONPatch operations to apply */
        operations: {
          /**
           * @description Operation type
           * @enum {string}
           */
          op: 'add' | 'replace' | 'remove';
          /** @description JSON Pointer to the field to modify */
          path: string;
          /** @description Value to set (for add/replace operations) */
          value?: unknown;
        }[];
      }[];
    };
    /** @description Observed state of a ClusterTrait */
    ClusterTraitStatus: Record<string, never>;
    /** @description Paginated list of component types */
    ComponentTypeList: {
      items: components['schemas']['ComponentType'][];
      pagination?: components['schemas']['Pagination'];
    };
    /** @description Desired state of a ComponentType */
    ComponentTypeSpec: {
      /**
       * @description Primary workload resource type for this component type
       * @example deployment
       * @enum {string}
       */
      workloadType: 'deployment' | 'statefulset' | 'cronjob' | 'job' | 'proxy';
      /**
       * @description List of allowed ComponentWorkflow names for this component type
       * @example [
       *       "docker-build",
       *       "buildpack-build"
       *     ]
       */
      allowedWorkflows?: string[];
      /** @description Developer-configurable schema definition */
      schema?: {
        /** @description Reusable type definitions */
        types?: {
          [key: string]: unknown;
        };
        /** @description Static developer configuration parameters */
        parameters?: {
          [key: string]: unknown;
        };
        /** @description Environment-specific overrides for platform engineers */
        envOverrides?: {
          [key: string]: unknown;
        };
      };
      /** @description Pre-configured trait instances embedded in this component type */
      traits?: {
        /**
         * @description Kind of trait (Trait or ClusterTrait)
         * @default Trait
         * @enum {string}
         */
        kind: 'Trait' | 'ClusterTrait';
        /** @description Name of the Trait resource */
        name: string;
        /** @description Unique instance name for this trait */
        instanceName: string;
        /** @description Trait parameter bindings (concrete values or CEL expressions) */
        parameters?: {
          [key: string]: unknown;
        };
        /** @description Trait environment override bindings */
        envOverrides?: {
          [key: string]: unknown;
        };
      }[];
      /** @description Restricts which Trait or ClusterTrait CRs developers can attach to Components of this type. Each entry is an object with "kind" (Trait or ClusterTrait, defaults to Trait) and "name". For example: {"kind": "Trait", "name": "my-trait"} or {"kind": "ClusterTrait", "name": "my-cluster-trait"}. If empty or omitted, no additional component-level traits are permitted (only embedded traits defined in spec.traits are allowed). */
      allowedTraits?: {
        /**
         * @description Kind of trait reference
         * @default Trait
         * @enum {string}
         */
        kind: 'Trait' | 'ClusterTrait';
        /** @description Name of the Trait or ClusterTrait resource */
        name: string;
      }[];
      /** @description CEL-based validation rules evaluated during rendering */
      validations?: {
        /** @description CEL expression wrapped in ${...} that must evaluate to true */
        rule: string;
        /** @description Error message shown when the rule evaluates to false */
        message: string;
      }[];
      /** @description Templates that generate Kubernetes resources dynamically */
      resources: {
        /** @description Unique identifier for this resource within the component type */
        id: string;
        /**
         * @description Target plane for deployment
         * @default dataplane
         * @enum {string}
         */
        targetPlane: 'dataplane' | 'observabilityplane';
        /** @description CEL expression determining if this resource should be created */
        includeWhen?: string;
        /** @description CEL expression for generating multiple resources from a list */
        forEach?: string;
        /** @description Loop variable name when using forEach */
        var?: string;
        /** @description Kubernetes resource template with CEL expressions */
        template: {
          [key: string]: unknown;
        };
      }[];
    };
    /** @description Observed state of a ComponentType */
    ComponentTypeStatus: Record<string, never>;
    /**
     * @description ComponentType resource (Kubernetes object without kind/apiVersion).
     *     Defines workload templates used by platform engineers to govern component behavior.
     */
    ComponentType: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ComponentTypeSpec'];
      readonly status?: components['schemas']['ComponentTypeStatus'];
    };
    /** @description Paginated list of traits */
    TraitList: {
      items: components['schemas']['Trait'][];
      pagination?: components['schemas']['Pagination'];
    };
    /** @description Desired state of a Trait */
    TraitSpec: {
      /** @description Trait parameter schema definition */
      schema?: {
        /** @description Reusable type definitions */
        types?: {
          [key: string]: unknown;
        };
        /** @description Developer-facing configuration options */
        parameters?: {
          [key: string]: unknown;
        };
        /** @description Environment-specific overrides */
        envOverrides?: {
          [key: string]: unknown;
        };
      };
      /** @description CEL-based validation rules evaluated during rendering */
      validations?: {
        /** @description CEL expression wrapped in ${...} that must evaluate to true */
        rule: string;
        /** @description Error message shown when the rule evaluates to false */
        message: string;
      }[];
      /** @description New Kubernetes resources to create when this trait is applied */
      creates?: {
        /**
         * @description Target plane for deployment
         * @default dataplane
         * @enum {string}
         */
        targetPlane: 'dataplane' | 'observabilityplane';
        /** @description CEL expression determining if this resource should be created */
        includeWhen?: string;
        /** @description CEL expression for generating multiple resources from a list */
        forEach?: string;
        /** @description Loop variable name when using forEach */
        var?: string;
        /** @description Kubernetes resource template with CEL expressions */
        template: {
          [key: string]: unknown;
        };
      }[];
      /** @description Modifications to existing resources generated by the ComponentType */
      patches?: {
        /** @description CEL expression for repeating this patch */
        forEach?: string;
        /** @description Loop variable name when using forEach */
        var?: string;
        /** @description Target resource to patch */
        target: {
          /** @description API group of the resource */
          group: string;
          /** @description API version of the resource */
          version: string;
          /** @description Resource type to patch */
          kind: string;
          /** @description CEL expression to filter which resources to patch */
          where?: string;
        };
        /**
         * @description Target plane for this patch
         * @default dataplane
         * @enum {string}
         */
        targetPlane: 'dataplane' | 'observabilityplane';
        /** @description JSONPatch operations to apply */
        operations: {
          /**
           * @description Operation type
           * @enum {string}
           */
          op: 'add' | 'replace' | 'remove';
          /** @description JSON Pointer to the field to modify */
          path: string;
          /** @description Value to set (for add/replace operations) */
          value?: unknown;
        }[];
      }[];
    };
    /** @description Observed state of a Trait */
    TraitStatus: Record<string, never>;
    /**
     * @description Trait resource (Kubernetes object without kind/apiVersion).
     *     Defines composable cross-cutting concerns that can be applied to components.
     */
    Trait: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['TraitSpec'];
      readonly status?: components['schemas']['TraitStatus'];
    };
    /**
     * @description JSON Schema response for component types, traits, or workflows
     * @example {
     *       "type": "object",
     *       "properties": {
     *         "replicas": {
     *           "type": "integer",
     *           "default": 1
     *         },
     *         "port": {
     *           "type": "integer",
     *           "default": 8080
     *         }
     *       }
     *     }
     */
    SchemaResponse: {
      [key: string]: unknown;
    };
    /** @description Paginated list of workflows */
    WorkflowList: {
      items: components['schemas']['Workflow'][];
      pagination: components['schemas']['Pagination'];
    };
    /** @description Generic workflow resource */
    Workflow: {
      /**
       * @description Workflow name (unique within namespace)
       * @example database-migration
       */
      name: string;
      /**
       * @description Human-readable display name
       * @example Database Migration
       */
      displayName?: string;
      /**
       * @description Workflow description
       * @example Runs database migration scripts
       */
      description?: string;
      /**
       * Format: date-time
       * @description Creation timestamp
       * @example 2025-01-06T10:00:00Z
       */
      createdAt: string;
    };
    /** @description Paginated list of workflow runs */
    WorkflowRunList: {
      items: components['schemas']['WorkflowRun'][];
      pagination: components['schemas']['Pagination'];
    };
    /** @description Generic workflow run (execution) */
    WorkflowRun: {
      /**
       * @description Workflow run name
       * @example database-migration-run-1234
       */
      name: string;
      /**
       * @description Unique identifier
       * @example 550e8400-e29b-41d4-a716-446655440000
       */
      uuid?: string;
      /**
       * @description Parent workflow name
       * @example database-migration
       */
      workflowName: string;
      /**
       * @description Organization name
       * @example my-org
       */
      orgName: string;
      /**
       * @description Current execution status
       * @example Succeeded
       * @enum {string}
       */
      status: 'Pending' | 'Running' | 'Succeeded' | 'Failed' | 'Error';
      /**
       * @description User-defined workflow parameters
       * @example {
       *       "database_url": "postgresql://localhost:5432/mydb",
       *       "migration_version": "v2.1.0"
       *     }
       */
      parameters?: {
        [key: string]: unknown;
      };
      /**
       * Format: date-time
       * @description Creation timestamp
       * @example 2025-01-06T10:00:00Z
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Completion timestamp
       * @example 2025-01-06T10:05:00Z
       */
      finishedAt?: string;
      /**
       * @description Detailed execution phase
       * @example Clone completed, build in progress
       */
      phase?: string;
    };
    /** @description Status of a workflow run including per-step details */
    WorkflowRunStatusResponse: {
      /**
       * @description Overall workflow run status
       * @example Running
       * @enum {string}
       */
      status: 'Pending' | 'Running' | 'Succeeded' | 'Failed' | 'Error';
      /** @description Per-step status details */
      steps: components['schemas']['WorkflowStepStatus'][];
      /**
       * @description Whether live logs/events are available from the build plane
       * @example true
       */
      hasLiveObservability: boolean;
    };
    /** @description Status of an individual workflow step */
    WorkflowStepStatus: {
      /**
       * @description Step name
       * @example clone-step
       */
      name: string;
      /**
       * @description Step phase
       * @example Succeeded
       * @enum {string}
       */
      phase:
        | 'Pending'
        | 'Running'
        | 'Succeeded'
        | 'Failed'
        | 'Skipped'
        | 'Error';
      /**
       * Format: date-time
       * @description When the step started
       * @example 2025-01-06T10:00:00Z
       */
      startedAt?: string;
      /**
       * Format: date-time
       * @description When the step finished
       * @example 2025-01-06T10:01:00Z
       */
      finishedAt?: string;
    };
    /** @description A single log entry from a workflow run */
    WorkflowRunLogEntry: {
      /**
       * Format: date-time
       * @description Log entry timestamp
       * @example 2025-01-06T10:00:00Z
       */
      timestamp?: string;
      /**
       * @description Log message
       * @example Step 1: Cloning repository...
       */
      log: string;
    };
    /** @description A single Kubernetes event from a workflow run */
    WorkflowRunEventEntry: {
      /**
       * Format: date-time
       * @description Event timestamp
       * @example 2025-01-06T10:00:00Z
       */
      timestamp: string;
      /**
       * @description Event type
       * @example Normal
       */
      type: string;
      /**
       * @description Short machine-understandable reason for the event
       * @example Started
       */
      reason: string;
      /**
       * @description Human-readable description of the event
       * @example Container main started
       */
      message: string;
    };
    /** @description Request to create a new workflow run */
    CreateWorkflowRunRequest: {
      /**
       * @description Name of the workflow to execute
       * @example database-migration
       */
      workflowName: string;
      /**
       * @description User-defined workflow parameters
       * @example {
       *       "database_url": "postgresql://localhost:5432/mydb",
       *       "migration_version": "v2.1.0"
       *     }
       */
      parameters: {
        [key: string]: unknown;
      };
    };
    /** @description Paginated list of component workflow templates */
    ComponentWorkflowTemplateList: {
      items: components['schemas']['ComponentWorkflowTemplate'][];
      pagination: components['schemas']['Pagination'];
    };
    /** @description Component workflow template resource */
    ComponentWorkflowTemplate: {
      /**
       * @description ComponentWorkflow name (unique within namespace)
       * @example docker-build
       */
      name: string;
      /**
       * @description Human-readable display name
       * @example Docker Build
       */
      displayName?: string;
      /**
       * @description ComponentWorkflow description
       * @example Builds container images using Docker
       */
      description?: string;
      /**
       * Format: date-time
       * @description Creation timestamp
       * @example 2025-01-06T10:00:00Z
       */
      createdAt: string;
    };
    /** @description Request to update component workflow parameters */
    UpdateComponentWorkflowRequest: {
      /**
       * @description ComponentWorkflow template name to use
       * @example docker-build
       */
      workflowName?: string;
      /** @description System parameters including repository configuration */
      systemParameters?: {
        repository?: {
          /**
           * @description Git repository URL
           * @example https://github.com/org/repo.git
           */
          url?: string;
          revision?: {
            /**
             * @description Git branch
             * @example main
             */
            branch?: string;
            /**
             * @description Specific commit SHA
             * @example abc1234
             */
            commit?: string;
          };
          /**
           * @description Path to application within repository
           * @example ./services/api
           */
          appPath?: string;
        };
      };
      /** @description User-defined workflow parameters */
      parameters?: {
        [key: string]: unknown;
      };
    };
    /** @description Paginated list of component workflow runs */
    ComponentWorkflowRunList: {
      items: components['schemas']['ComponentWorkflowRun'][];
      pagination: components['schemas']['Pagination'];
    };
    /** @description Component workflow run (build execution) */
    ComponentWorkflowRun: {
      /**
       * @description Workflow run name
       * @example api-service-run-1234
       */
      name: string;
      /**
       * @description Unique identifier
       * @example 550e8400-e29b-41d4-a716-446655440000
       */
      uuid?: string;
      /**
       * @description Parent component name
       * @example api-service
       */
      componentName: string;
      /**
       * @description Parent project name
       * @example my-project
       */
      projectName: string;
      /**
       * @description Parent namespace name
       * @example my-namespace
       */
      namespaceName: string;
      /**
       * @description Run status
       * @example Running
       */
      status?: string;
      /**
       * @description Git commit SHA being built
       * @example abc1234def5678
       */
      commit?: string;
      /**
       * @description Built container image
       * @example registry.example.com/my-namespace/api-service:abc1234
       */
      image?: string;
      workflow?: components['schemas']['ComponentWorkflowConfig'];
      /**
       * Format: date-time
       * @description Creation timestamp
       * @example 2025-01-06T10:00:00Z
       */
      createdAt: string;
    };
    /** @description Request to patch a component */
    PatchComponentRequest: {
      /**
       * @description Controls auto-deployment to default environment
       * @example true
       */
      autoDeploy?: boolean;
      /** @description ComponentType parameters */
      parameters?: {
        [key: string]: unknown;
      };
    };
    /** @description Trait attached to a component */
    ComponentTrait: {
      /**
       * @description Kind of trait resource (Trait for namespace-scoped, ClusterTrait for cluster-scoped)
       * @default Trait
       * @example Trait
       * @enum {string}
       */
      kind: 'Trait' | 'ClusterTrait';
      /**
       * @description Trait template name
       * @example autoscaler
       */
      name: string;
      /**
       * @description Instance name for this trait attachment
       * @example my-autoscaler
       */
      instanceName: string;
      /** @description Trait parameters */
      parameters?: {
        [key: string]: unknown;
      };
    };
    /** @description Paginated list of component releases */
    ComponentReleaseList: {
      items: components['schemas']['ComponentRelease'][];
      pagination: components['schemas']['Pagination'];
    };
    /**
     * @description ComponentRelease resource (Kubernetes object without kind/apiVersion).
     *     Immutable snapshot of component state at release time.
     */
    ComponentRelease: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ComponentReleaseSpec'];
      /** @description ComponentRelease status (currently empty, immutable after creation) */
      readonly status?: Record<string, never>;
    };
    /** @description Desired state of a ComponentRelease */
    ComponentReleaseSpec: {
      /** @description Identifies the component and project this release belongs to */
      owner: {
        /**
         * @description Parent project name
         * @example my-project
         */
        projectName: string;
        /**
         * @description Parent component name
         * @example api-service
         */
        componentName: string;
      };
      /** @description Frozen ComponentType spec at release time */
      componentType: {
        [key: string]: unknown;
      };
      /** @description Frozen trait specs at release time (keyed by trait name) */
      traits?: {
        [key: string]: unknown;
      };
      /** @description Snapshot of component parameters and trait configs */
      componentProfile?: {
        /** @description Component type parameters */
        parameters?: {
          [key: string]: unknown;
        };
        /** @description Component trait instances */
        traits?: components['schemas']['ComponentTrait'][];
      };
      /** @description Frozen workload spec at release time */
      workload: {
        [key: string]: unknown;
      };
    };
    /** @description Paginated list of release bindings */
    ReleaseBindingList: {
      items: components['schemas']['ReleaseBinding'][];
      pagination: components['schemas']['Pagination'];
    };
    /**
     * @description ReleaseBinding resource (Kubernetes object without kind/apiVersion).
     *     Binds a ComponentRelease to a specific environment.
     */
    ReleaseBinding: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ReleaseBindingSpec'];
      readonly status?: components['schemas']['ReleaseBindingStatus'];
    };
    /** @description Desired state of a ReleaseBinding */
    ReleaseBindingSpec: {
      /** @description Owner identifies the component and project this ReleaseBinding belongs to */
      owner: {
        /**
         * @description Name of the project
         * @example my-project
         */
        projectName: string;
        /**
         * @description Name of the component
         * @example api-service
         */
        componentName: string;
      };
      /**
       * @description Target environment name
       * @example dev
       */
      environment: string;
      /**
       * @description Reference to component release
       * @example v1.0.0
       */
      releaseName?: string;
      /** @description Environment-specific ComponentType overrides */
      componentTypeEnvOverrides?: {
        [key: string]: unknown;
      };
      /** @description Environment-specific trait overrides */
      traitOverrides?: {
        [key: string]: unknown;
      };
      workloadOverrides?: components['schemas']['WorkloadOverrides'];
      /**
       * @description Controls the state of the Release created by this binding
       * @default Active
       * @example Active
       * @enum {string}
       */
      state: 'Active' | 'Undeploy';
    };
    /** @description Observed state of a ReleaseBinding */
    ReleaseBindingStatus: {
      /** @description Latest available observations of the ReleaseBinding's current state */
      conditions?: components['schemas']['Condition'][];
      /** @description Resolved invoke URLs for each named workload endpoint */
      endpoints?: {
        /**
         * @description Endpoint name as defined in the Workload spec
         * @example http
         */
        name: string;
        /**
         * @description Resolved public URL for this endpoint
         * @example https://api-service-dev-default.example.com
         */
        invokeURL: string;
      }[];
    };
    /** @description Environment-specific workload overrides */
    WorkloadOverrides: {
      container?: components['schemas']['ContainerOverride'];
    };
    /** @description Container-level overrides */
    ContainerOverride: {
      env?: components['schemas']['EnvVar'][];
      files?: components['schemas']['FileVar'][];
    };
    /** @description Environment variable */
    EnvVar: {
      /**
       * @description Variable key/name
       * @example DATABASE_URL
       */
      key: string;
      /**
       * @description Variable value
       * @example postgres://localhost:5432/db
       */
      value?: string;
      valueFrom?: components['schemas']['EnvVarValueFrom'];
    };
    /** @description Value source reference */
    EnvVarValueFrom: {
      /** @description Secret reference */
      secretRef?: {
        /** @description Secret name */
        name?: string;
        /** @description Secret key */
        key?: string;
      };
    };
    /** @description File mount variable */
    FileVar: {
      /**
       * @description File key/name
       * @example config.yaml
       */
      key: string;
      /**
       * @description Mount path in container
       * @example /app/config
       */
      mountPath: string;
      /** @description File content */
      value?: string;
      valueFrom?: components['schemas']['EnvVarValueFrom'];
    };
    /** @description Paginated list of releases */
    ReleaseList: {
      items: components['schemas']['Release'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description Release resource (Kubernetes object without kind/apiVersion).
     *     Contains the final Kubernetes manifests deployed to data plane clusters.
     */
    Release: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ReleaseSpec'];
      readonly status?: components['schemas']['ReleaseStatus'];
    };
    /** @description Desired state of a Release */
    ReleaseSpec: {
      /** @description Owner identifies the component and project this Release belongs to */
      owner: {
        /**
         * @description Name of the project
         * @example my-project
         */
        projectName: string;
        /**
         * @description Name of the component
         * @example api-service
         */
        componentName: string;
      };
      /**
       * @description Target environment for this release
       * @example dev
       */
      environmentName: string;
      /** @description Kubernetes resource templates to apply to the data plane */
      resources?: {
        /** @description Unique identifier for the resource */
        id: string;
        /** @description Complete Kubernetes resource definition */
        object: {
          [key: string]: unknown;
        };
      }[];
      /**
       * @description Target plane for deployment
       * @default dataplane
       * @example dataplane
       * @enum {string}
       */
      targetPlane: 'dataplane' | 'observabilityplane';
      /**
       * @description Watch interval for stable release resources (e.g. 5m, 30s)
       * @example 5m
       */
      interval?: string;
      /**
       * @description Watch interval for transitioning release resources (e.g. 10s)
       * @example 10s
       */
      progressingInterval?: string;
    };
    /** @description Observed state of a Release */
    ReleaseStatus: {
      /** @description Latest available observations of the Release's current state */
      conditions?: components['schemas']['Condition'][];
      /** @description Resources applied to the data plane with their observed status */
      resources?: {
        /** @description Resource identifier matching spec.resources */
        id?: string;
        /** @description API group of the resource */
        group?: string;
        /** @description API version of the resource */
        version?: string;
        /** @description Kind of the resource */
        kind?: string;
        /** @description Name of the resource in the data plane */
        name?: string;
        /** @description Namespace of the resource in the data plane */
        namespace?: string;
        /**
         * @description Health status of the resource
         * @enum {string}
         */
        healthStatus?:
          | 'Unknown'
          | 'Progressing'
          | 'Healthy'
          | 'Suspended'
          | 'Degraded';
        /** @description Full status of the resource from the data plane */
        status?: {
          [key: string]: unknown;
        };
      }[];
    };
    /** @description Reference to a parent resource in the resource tree */
    ResourceRef: {
      /** @description API group of the resource */
      group?: string;
      /** @description API version of the resource */
      version: string;
      /** @description Kind of the resource */
      kind: string;
      /** @description Namespace of the resource */
      namespace?: string;
      /** @description Name of the resource */
      name: string;
      /** @description UID of the resource */
      uid: string;
    };
    /** @description Health status for a resource node */
    HealthInfo: {
      /** @description Health status (Healthy, Degraded, Progressing, Unknown, etc.) */
      status: string;
      /** @description Optional human-readable message explaining the health status */
      message?: string;
    };
    /** @description A single resource in the resource tree */
    ResourceNode: {
      /** @description API group of the resource */
      group?: string;
      /** @description API version of the resource */
      version: string;
      /** @description Kind of the resource */
      kind: string;
      /** @description Namespace of the resource */
      namespace?: string;
      /** @description Name of the resource */
      name: string;
      /** @description UID of the resource */
      uid: string;
      /** @description Resource version from Kubernetes */
      resourceVersion?: string;
      /**
       * Format: date-time
       * @description Creation timestamp of the resource
       */
      createdAt?: string;
      /** @description References to parent resources */
      parentRefs?: components['schemas']['ResourceRef'][];
      /** @description Full Kubernetes resource object */
      object: {
        [key: string]: unknown;
      };
      health?: components['schemas']['HealthInfo'];
    };
    /** @description Response containing the resource tree for a release */
    ResourceTreeResponse: {
      /** @description All resource nodes in the tree */
      nodes: components['schemas']['ResourceNode'][];
    };
    /** @description A Kubernetes event associated with a resource */
    ResourceEvent: {
      /**
       * @description Type of the event (Normal or Warning)
       * @example Normal
       */
      type: string;
      /**
       * @description Short machine-readable reason for the event
       * @example Scheduled
       */
      reason: string;
      /**
       * @description Human-readable description of the event
       * @example Successfully assigned default/my-pod to node-1
       */
      message: string;
      /**
       * @description Number of times this event has occurred
       * @example 3
       */
      count?: number;
      /**
       * Format: date-time
       * @description First time this event was recorded
       */
      firstTimestamp?: string;
      /**
       * Format: date-time
       * @description Most recent time this event was recorded
       */
      lastTimestamp?: string;
      /**
       * @description Component that generated the event
       * @example default-scheduler
       */
      source?: string;
    };
    /** @description Response containing events for a specific resource */
    ResourceEventsResponse: {
      /** @description Kubernetes events for the resource */
      events: components['schemas']['ResourceEvent'][];
    };
    /** @description A single log entry from a pod */
    PodLogEntry: {
      /**
       * Format: date-time
       * @description Timestamp of the log entry in RFC3339 format
       * @example 2024-01-10T12:34:56.789Z
       */
      timestamp: string;
      /**
       * @description Log message content
       * @example Starting application server on port 8080
       */
      log: string;
    };
    /** @description Response containing logs for a specific pod */
    ResourcePodLogsResponse: {
      /** @description Log entries from the pod */
      logEntries: components['schemas']['PodLogEntry'][];
    };
    /** @description Request to deploy a release */
    DeployReleaseRequest: {
      /**
       * @description Component release name to deploy
       * @example v1.0.0
       */
      releaseName: string;
    };
    /** @description Request to promote a component between environments */
    PromoteComponentRequest: {
      /**
       * @description Source environment name
       * @example dev
       */
      sourceEnv: string;
      /**
       * @description Target environment name
       * @example staging
       */
      targetEnv: string;
    };
    /** @description Request to generate an immutable release snapshot from the current component state */
    GenerateReleaseRequest: {
      /**
       * @description Optional release name (auto-generated if not provided)
       * @example v1.0.0
       */
      releaseName?: string;
    };
    /** @description Simple message response */
    MessageResponse: {
      /**
       * @description Response message
       * @example Operation completed successfully
       */
      message: string;
    };
    /**
     * @description Cluster-scoped authorization role (Kubernetes CRD).
     *     Defines a set of actions that can be assigned to subjects via role bindings.
     */
    AuthzClusterRole: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['AuthzClusterRoleSpec'];
    };
    /** @description Specification for a cluster-scoped authorization role */
    AuthzClusterRoleSpec: {
      /**
       * @description List of actions this role permits
       * @example [
       *       "project:create",
       *       "project:view",
       *       "project:delete"
       *     ]
       */
      actions: string[];
      /**
       * @description Human-readable description of the role
       * @example Full cluster administration access
       */
      description?: string;
    };
    /** @description List of cluster-scoped authorization roles */
    AuthzClusterRoleList: {
      items: components['schemas']['AuthzClusterRole'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description Namespace-scoped authorization role (Kubernetes CRD).
     *     Defines a set of actions that can be assigned to subjects via role bindings within a namespace.
     */
    AuthzRole: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['AuthzRoleSpec'];
    };
    /** @description Specification for a namespace-scoped authorization role */
    AuthzRoleSpec: {
      /**
       * @description List of actions this role permits
       * @example [
       *       "component:create",
       *       "component:view"
       *     ]
       */
      actions: string[];
      /**
       * @description Human-readable description of the role
       * @example Developer access within namespace
       */
      description?: string;
    };
    /** @description List of namespace-scoped authorization roles */
    AuthzRoleList: {
      items: components['schemas']['AuthzRole'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description Cluster-scoped role binding (Kubernetes CRD).
     *     Binds a cluster role to a subject identified by an entitlement claim.
     */
    AuthzClusterRoleBinding: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['AuthzClusterRoleBindingSpec'];
    };
    /** @description Specification for a cluster-scoped role binding */
    AuthzClusterRoleBindingSpec: {
      entitlement: components['schemas']['AuthzEntitlementClaim'];
      roleRef: components['schemas']['AuthzRoleRef'];
      /**
       * @description Policy effect (allow or deny)
       * @default allow
       * @example allow
       * @enum {string}
       */
      effect: 'allow' | 'deny';
    };
    /** @description List of cluster-scoped role bindings */
    AuthzClusterRoleBindingList: {
      items: components['schemas']['AuthzClusterRoleBinding'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description Namespace-scoped role binding (Kubernetes CRD).
     *     Binds a role to a subject identified by an entitlement claim within a namespace.
     */
    AuthzRoleBinding: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['AuthzRoleBindingSpec'];
    };
    /** @description Specification for a namespace-scoped role binding */
    AuthzRoleBindingSpec: {
      entitlement: components['schemas']['AuthzEntitlementClaim'];
      roleRef: components['schemas']['AuthzRoleRef'];
      targetPath?: components['schemas']['AuthzTargetPath'];
      /**
       * @description Policy effect (allow or deny)
       * @default allow
       * @example allow
       * @enum {string}
       */
      effect: 'allow' | 'deny';
    };
    /** @description List of namespace-scoped role bindings */
    AuthzRoleBindingList: {
      items: components['schemas']['AuthzRoleBinding'][];
      pagination?: components['schemas']['Pagination'];
    };
    /** @description Entitlement claim-value pair for subject identification */
    AuthzEntitlementClaim: {
      /**
       * @description JWT claim name
       * @example groups
       */
      claim: string;
      /**
       * @description Entitlement value
       * @example admin-group
       */
      value: string;
    };
    /** @description Reference to an AuthzRole or AuthzClusterRole */
    AuthzRoleRef: {
      /**
       * @description Kind of role (AuthzRole or AuthzClusterRole)
       * @example AuthzClusterRole
       * @enum {string}
       */
      kind: 'AuthzRole' | 'AuthzClusterRole';
      /**
       * @description Name of the role
       * @example admin
       */
      name: string;
    };
    /** @description Target resource path within a namespace (project/component scope) */
    AuthzTargetPath: {
      /**
       * @description Project name
       * @example my-project
       */
      project?: string;
      /**
       * @description Component name
       * @example api-service
       */
      component?: string;
    };
    /** @description Entitlement with claim and value */
    Entitlement: {
      /**
       * @description JWT claim name
       * @example group
       */
      claim: string;
      /**
       * @description Entitlement value
       * @example admin-group
       */
      value: string;
    };
    /** @description Resource hierarchy scope */
    ResourceHierarchy: {
      /**
       * @description Namespace name
       * @example my-namespace
       */
      namespace?: string;
      /**
       * @description Project name
       * @example my-project
       */
      project?: string;
      /**
       * @description Component name
       * @example api-service
       */
      component?: string;
    };
    /** @description Additional context for authorization */
    AuthzContext: {
      [key: string]: unknown;
    };
    /** @description Authenticated subject context */
    SubjectContext: {
      /**
       * @description Subject type
       * @example user
       * @enum {string}
       */
      type: 'user' | 'service_account';
      /**
       * @description Entitlement claim name
       * @example group
       */
      entitlement_claim: string;
      /**
       * @description Entitlement values
       * @example [
       *       "admin-group",
       *       "dev-group"
       *     ]
       */
      entitlement_values: string[];
    };
    /** @description Resource for authorization evaluation */
    Resource: {
      /**
       * @description Resource type
       * @example component
       */
      type: string;
      /**
       * @description Resource ID
       * @example api-service
       */
      id?: string;
      hierarchy: components['schemas']['ResourceHierarchy'];
    };
    /** @description Single authorization evaluation request */
    EvaluateRequest: {
      subject_context: components['schemas']['SubjectContext'];
      resource: components['schemas']['Resource'];
      /**
       * @description Action to evaluate
       * @example read
       */
      action: string;
      context?: components['schemas']['AuthzContext'];
    };
    /** @description Authorization decision */
    Decision: {
      /**
       * @description Authorization result (true = allowed)
       * @example true
       */
      decision: boolean;
      /** @description Additional decision context */
      context?: {
        /**
         * @description Reason for the decision
         * @example User has admin role
         */
        reason?: string;
      };
    };
    /** @description Capabilities for a specific action */
    ActionCapability: {
      /** @description Resources where action is allowed */
      allowed?: components['schemas']['CapabilityResource'][];
      /** @description Resources where action is denied */
      denied?: components['schemas']['CapabilityResource'][];
    };
    /** @description Resource with permission details */
    CapabilityResource: {
      /**
       * @description Full resource path
       * @example namespace/acme/project/payment
       */
      path?: string;
      /** @description Additional instance-level restrictions */
      constraints?: {
        [key: string]: unknown;
      };
    };
    /** @description User authorization profile response */
    UserCapabilitiesResponse: {
      user?: components['schemas']['SubjectContext'];
      /** @description Map of action to capabilities */
      capabilities?: {
        [key: string]: components['schemas']['ActionCapability'];
      };
      /**
       * Format: date-time
       * @description Time when capabilities were evaluated
       * @example 2025-01-06T10:00:00Z
       */
      evaluatedAt?: string;
    };
    /** @description Authorization role with permitted actions (legacy) */
    Role: {
      /**
       * @description Unique role name
       * @example admin
       */
      name: string;
      /**
       * @description List of actions this role permits
       * @example [
       *       "read",
       *       "write",
       *       "delete"
       *     ]
       */
      actions: string[];
      /**
       * @description Namespace for namespace-scoped roles, empty for cluster roles
       * @example my-namespace
       */
      namespace?: string;
      /**
       * @description Human-readable description of the role
       * @example Full administrative access
       */
      description?: string;
    };
    /** @description Request to update a role's actions (legacy) */
    UpdateRoleRequest: {
      /**
       * @description New list of actions for the role
       * @example [
       *       "read",
       *       "write"
       *     ]
       */
      actions: string[];
    };
    /** @description Target resource path within a namespace (project/component only) (legacy) */
    TargetPath: {
      /**
       * @description Project name
       * @example my-project
       */
      project?: string;
      /**
       * @description Component name
       * @example api-service
       */
      component?: string;
    };
    /** @description Mapping of a role to an entitlement within a scope (legacy) */
    RoleEntitlementMapping: {
      /**
       * @description Unique mapping name
       * @example admin-binding
       */
      name: string;
      role: components['schemas']['RoleRef'];
      entitlement: components['schemas']['Entitlement'];
      hierarchy: components['schemas']['ResourceHierarchy'];
      /**
       * @description Policy effect (allow or deny)
       * @default allow
       * @example allow
       * @enum {string}
       */
      effect: 'allow' | 'deny';
      context?: components['schemas']['AuthzContext'];
    };
    /** @description Request to update a role mapping (legacy) */
    UpdateRoleMappingRequest: {
      role: components['schemas']['RoleRef'];
      entitlement: components['schemas']['Entitlement'];
      hierarchy: components['schemas']['ResourceHierarchy'];
      /**
       * @description Policy effect (allow or deny)
       * @default allow
       * @example allow
       * @enum {string}
       */
      effect: 'allow' | 'deny';
      context?: components['schemas']['AuthzContext'];
    };
    /** @description Reference to a cluster role by name only (legacy) */
    ClusterRoleRef: {
      /**
       * @description Cluster role name
       * @example admin
       */
      name: string;
    };
    /** @description Reference to a role by name and namespace (legacy) */
    RoleRef: {
      /**
       * @description Role name
       * @example developer
       */
      name: string;
      /**
       * @description Namespace for namespace-scoped roles, empty for cluster roles
       * @example my-namespace
       */
      namespace?: string;
    };
    /** @description Request to create a cluster-scoped role (legacy) */
    CreateClusterRoleRequest: {
      /**
       * @description Unique cluster role name
       * @example cluster-admin
       */
      name: string;
      /**
       * @description List of actions this role permits
       * @example [
       *       "read",
       *       "write",
       *       "delete"
       *     ]
       */
      actions: string[];
      /**
       * @description Human-readable description of the role
       * @example Full cluster administration access
       */
      description?: string;
    };
    /** @description Request to update a cluster role (legacy) */
    UpdateClusterRoleRequest: {
      /**
       * @description List of actions this role permits
       * @example [
       *       "read",
       *       "write"
       *     ]
       */
      actions: string[];
      /**
       * @description Human-readable description of the role
       * @example Updated cluster admin role
       */
      description?: string;
    };
    /** @description Request to create a cluster-scoped role binding (legacy) */
    CreateClusterRoleBindingRequest: {
      /**
       * @description Unique cluster role binding name
       * @example admin-binding
       */
      name: string;
      entitlement: components['schemas']['Entitlement'];
      /**
       * @description Cluster role name
       * @example admin
       */
      role: string;
      /**
       * @description Policy effect (allow or deny)
       * @default allow
       * @example allow
       * @enum {string}
       */
      effect: 'allow' | 'deny';
    };
    /** @description Request to update a cluster role binding (legacy) */
    UpdateClusterRoleBindingRequest: {
      entitlement: components['schemas']['Entitlement'];
      /**
       * @description Cluster role name
       * @example admin
       */
      role: string;
      /**
       * @description Policy effect (allow or deny)
       * @default allow
       * @example allow
       * @enum {string}
       */
      effect: 'allow' | 'deny';
    };
    /** @description Request to create a namespace-scoped role (legacy) */
    CreateNamespaceRoleRequest: {
      /**
       * @description Unique namespace role name
       * @example developer
       */
      name: string;
      /**
       * @description List of actions this role permits
       * @example [
       *       "read",
       *       "write"
       *     ]
       */
      actions: string[];
      /**
       * @description Human-readable description of the role
       * @example Developer access within namespace
       */
      description?: string;
    };
    /** @description Request to update a namespace role (legacy) */
    UpdateNamespaceRoleRequest: {
      /**
       * @description List of actions this role permits
       * @example [
       *       "read",
       *       "write"
       *     ]
       */
      actions: string[];
      /**
       * @description Human-readable description of the role
       * @example Updated developer role
       */
      description?: string;
    };
    /** @description Request to create a namespace-scoped role binding (legacy) */
    CreateNamespaceRoleBindingRequest: {
      /**
       * @description Unique namespace role binding name
       * @example developer-binding
       */
      name: string;
      entitlement: components['schemas']['Entitlement'];
      role: components['schemas']['RoleRef'];
      targetPath?: components['schemas']['TargetPath'];
      /**
       * @description Policy effect (allow or deny)
       * @default allow
       * @example allow
       * @enum {string}
       */
      effect: 'allow' | 'deny';
    };
    /** @description Request to update a namespace role binding (legacy) */
    UpdateNamespaceRoleBindingRequest: {
      entitlement: components['schemas']['Entitlement'];
      role: components['schemas']['RoleRef'];
      targetPath: components['schemas']['TargetPath'];
      /**
       * @description Policy effect (allow or deny)
       * @default allow
       * @example allow
       * @enum {string}
       */
      effect: 'allow' | 'deny';
    };
    /** @description Response after processing a webhook event */
    WebhookEventResponse: {
      /**
       * @description Whether the webhook was processed successfully
       * @example true
       */
      success: boolean;
      /**
       * @description Status message
       * @example Webhook processed successfully
       */
      message: string;
      /**
       * @description List of components affected by this webhook
       * @example [
       *       "api-service",
       *       "web-app"
       *     ]
       */
      affectedComponents?: string[];
      /**
       * @description Number of builds triggered
       * @example 2
       */
      triggeredBuilds: number;
    };
    /** @description Paginated list of secret references */
    SecretReferenceList: {
      items: components['schemas']['SecretReference'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description SecretReference resource (Kubernetes object without kind/apiVersion).
     *     Defines references to external secrets that are synced into the cluster.
     */
    SecretReference: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['SecretReferenceSpec'];
      readonly status?: components['schemas']['SecretReferenceStatus'];
    };
    /** @description Desired state of a SecretReference */
    SecretReferenceSpec: {
      template: components['schemas']['SecretTemplate'];
      /** @description Mapping of secret keys to external secret references */
      data: components['schemas']['SecretDataSource'][];
      /**
       * @description How often to reconcile/refresh the secret
       * @example 1h
       */
      refreshInterval?: string;
    };
    /** @description Observed state of a SecretReference */
    SecretReferenceStatus: {
      /** @description Latest available observations of the secret reference state */
      conditions?: components['schemas']['Condition'][];
      /**
       * Format: date-time
       * @description When the secret reference was last processed
       * @example 2025-01-06T11:00:00Z
       */
      lastRefreshTime?: string;
      /** @description Secret stores using this reference */
      secretStores?: components['schemas']['SecretStoreReference'][];
    };
    /** @description Structure of the resulting Kubernetes Secret */
    SecretTemplate: {
      /**
       * @description Type of the Kubernetes Secret
       * @default Opaque
       * @example Opaque
       * @enum {string}
       */
      type:
        | 'Opaque'
        | 'kubernetes.io/dockerconfigjson'
        | 'kubernetes.io/dockercfg'
        | 'kubernetes.io/basic-auth'
        | 'kubernetes.io/ssh-auth'
        | 'kubernetes.io/tls'
        | 'bootstrap.kubernetes.io/token';
      /** @description Additional metadata for the generated secret */
      metadata?: {
        /** @description Annotations to add to the secret */
        annotations?: {
          [key: string]: string;
        };
        /** @description Labels to add to the secret */
        labels?: {
          [key: string]: string;
        };
      };
    };
    /** @description Reference to a secret store */
    SecretStoreReference: {
      /**
       * @description Secret store name
       * @example vault-store
       */
      name: string;
      /**
       * @description Secret store namespace
       * @example my-namespace
       */
      namespace?: string;
      /**
       * @description Secret store kind
       * @example SecretStore
       */
      kind: string;
    };
    /** @description Secret data source mapping */
    SecretDataSource: {
      /**
       * @description Key name in the Kubernetes Secret
       * @example database-password
       */
      secretKey: string;
      remoteRef: components['schemas']['RemoteReference'];
    };
    /** @description Points to a secret in an external secret store */
    RemoteReference: {
      /**
       * @description Path in the external secret store
       * @example prod/database/password
       */
      key: string;
      /**
       * @description Specific field within the secret
       * @example password
       */
      property?: string;
      /**
       * @description Version of the secret to fetch
       * @example 1
       */
      version?: string;
    };
    /** @description Paginated list of workloads */
    WorkloadList: {
      items: components['schemas']['Workload'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description Workload resource (Kubernetes object without kind/apiVersion).
     *     Defines the source code, container, endpoints and connections for a component.
     */
    Workload: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['WorkloadSpec'];
      readonly status?: components['schemas']['WorkloadStatus'];
    };
    /** @description Desired state of a Workload */
    WorkloadSpec: {
      /** @description Owner reference for the workload */
      owner?: {
        /**
         * @description Name of the owning project
         * @example my-project
         */
        projectName: string;
        /**
         * @description Name of the owning component
         * @example api-service
         */
        componentName: string;
      };
      container?: components['schemas']['WorkloadContainer'];
      /** @description Named endpoint specifications */
      endpoints?: {
        [key: string]: components['schemas']['WorkloadEndpoint'];
      };
      /** @description Named connection specifications */
      connections?: {
        [key: string]: components['schemas']['WorkloadConnection'];
      };
    };
    /** @description Observed state of a Workload */
    WorkloadStatus: Record<string, never>;
    /** @description Container specification */
    WorkloadContainer: {
      /**
       * @description OCI image to run (digest or tag)
       * @example registry.example.com/my-namespace/api:v1.0.0
       */
      image: string;
      /** @description Container entrypoint */
      command?: string[];
      /** @description Container arguments */
      args?: string[];
      /** @description Environment variables */
      env?: components['schemas']['EnvVar'][];
      /** @description File configurations */
      files?: components['schemas']['FileVar'][];
    };
    /** @description Network endpoint specification */
    WorkloadEndpoint: {
      /** @description Additional endpoint visibilities beyond implicit project visibility */
      visibility?: ('project' | 'namespace' | 'internal' | 'external')[];
      /**
       * @description Protocol/technology of the endpoint
       * @enum {string}
       */
      type: 'HTTP' | 'REST' | 'gRPC' | 'GraphQL' | 'Websocket' | 'TCP' | 'UDP';
      /** @description Port exposed by the endpoint */
      port: number;
      /** @description Container listening port (defaults to port) */
      targetPort?: number;
      /** @description Human-readable name for the endpoint */
      displayName?: string;
      /** @description Base path of the API exposed via the endpoint */
      basePath?: string;
      /** @description API definition schema */
      schema?: {
        type?: string;
        content?: string;
      };
    };
    /** @description Internal API connection specification */
    WorkloadConnection: {
      /**
       * @description Connection type
       * @enum {string}
       */
      type: 'api';
      /** @description Connection configuration parameters */
      params?: {
        [key: string]: string;
      };
      /** @description How connection details are injected into the workload */
      inject: {
        /** @description Environment variables to inject */
        env: {
          /** @description Environment variable name */
          name: string;
          /** @description Template value using connection properties */
          value: string;
        }[];
      };
    };
    /** @description Paginated list of deployment pipelines */
    DeploymentPipelineList: {
      items: components['schemas']['DeploymentPipeline'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description DeploymentPipeline resource (Kubernetes object without kind/apiVersion).
     *     Defines promotion paths between environments for component deployments.
     */
    DeploymentPipeline: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['DeploymentPipelineSpec'];
      readonly status?: components['schemas']['DeploymentPipelineStatus'];
    };
    /** @description Desired state of a DeploymentPipeline */
    DeploymentPipelineSpec: {
      /** @description Promotion paths between environments */
      promotionPaths?: components['schemas']['PromotionPath'][];
    };
    /** @description Observed state of a DeploymentPipeline */
    DeploymentPipelineStatus: {
      /** @description Latest available observations of the deployment pipeline state */
      conditions?: components['schemas']['Condition'][];
    };
    /** @description Promotion path between environments */
    PromotionPath: {
      /**
       * @description Source environment name
       * @example dev
       */
      sourceEnvironmentRef: string;
      /** @description Target environments for promotion */
      targetEnvironmentRefs: components['schemas']['TargetEnvironmentRef'][];
    };
    /** @description Target environment reference with approval settings */
    TargetEnvironmentRef: {
      /**
       * @description Target environment name
       * @example staging
       */
      name: string;
      /**
       * @description Whether promotion requires approval
       * @example false
       */
      requiresApproval?: boolean;
      /**
       * @description Whether manual approval is required
       * @example true
       */
      isManualApprovalRequired?: boolean;
    };
    /** @description Paginated list of observability alerts notification channels */
    ObservabilityAlertsNotificationChannelList: {
      items: components['schemas']['ObservabilityAlertsNotificationChannel'][];
      pagination?: components['schemas']['Pagination'];
    };
    /**
     * @description ObservabilityAlertsNotificationChannel resource (Kubernetes object without kind/apiVersion).
     *     Defines a channel for sending alert notifications. Currently email and webhook notifications are supported.
     */
    ObservabilityAlertsNotificationChannel: {
      metadata: components['schemas']['ObjectMeta'];
      spec?: components['schemas']['ObservabilityAlertsNotificationChannelSpec'];
      readonly status?: components['schemas']['ObservabilityAlertsNotificationChannelStatus'];
    };
    /** @description Desired state of an ObservabilityAlertsNotificationChannel */
    ObservabilityAlertsNotificationChannelSpec: {
      /**
       * @description Name of the openchoreo environment this notification channel belongs to
       * @example dev
       */
      environment: string;
      /**
       * @description Whether this is the default notification channel for the environment
       * @default false
       */
      isEnvDefault: boolean;
      /**
       * @description Type of notification channel
       * @example email
       * @enum {string}
       */
      type: 'email' | 'webhook';
      emailConfig?: components['schemas']['NotificationEmailConfig'];
      webhookConfig?: components['schemas']['NotificationWebhookConfig'];
    } & (
      | {
          /** @enum {unknown} */
          type: 'email';
        }
      | {
          /** @enum {unknown} */
          type: 'webhook';
        }
    );
    /** @description Observed state of an ObservabilityAlertsNotificationChannel */
    ObservabilityAlertsNotificationChannelStatus: Record<string, never>;
    /** @description Configuration for email notification channels */
    NotificationEmailConfig: {
      /**
       * @description Sender email address
       * @example alerts@example.com
       */
      from: string;
      /**
       * @description List of recipient email addresses
       * @example [
       *       "team@example.com"
       *     ]
       */
      to: string[];
      smtp: components['schemas']['NotificationSMTPConfig'];
      template: components['schemas']['NotificationEmailTemplate'];
    };
    /** @description SMTP server configuration */
    NotificationSMTPConfig: {
      /**
       * @description SMTP server hostname
       * @example smtp.example.com
       */
      host: string;
      /**
       * @description SMTP server port
       * @example 587
       */
      port: number;
      auth: components['schemas']['NotificationSMTPAuth'];
      tls: components['schemas']['NotificationSMTPTLSConfig'];
    };
    /** @description SMTP authentication configuration */
    NotificationSMTPAuth: {
      username: components['schemas']['NotificationSecretValueFrom'];
      password: components['schemas']['NotificationSecretValueFrom'];
    };
    /** @description TLS configuration for SMTP */
    NotificationSMTPTLSConfig: {
      /**
       * @description Skip TLS certificate verification (not recommended for production)
       * @default false
       */
      insecureSkipVerify: boolean;
    };
    /** @description Email template with CEL expressions */
    NotificationEmailTemplate: {
      /**
       * @description Email subject line template using CEL expressions
       * @example [${alert.severity}] - ${alert.name} Triggered
       */
      subject: string;
      /**
       * @description Email body template using CEL expressions
       * @example Alert: ${alert.name} triggered at ${alert.startsAt}.
       */
      body: string;
    };
    /** @description Configuration for webhook notification channels */
    NotificationWebhookConfig: {
      /**
       * Format: uri
       * @description Webhook endpoint URL where alerts will be sent
       * @example https://hooks.slack.com/services/example
       */
      url: string;
      /** @description Optional HTTP headers to include in the webhook request */
      headers?: {
        [key: string]: components['schemas']['NotificationWebhookHeaderValue'];
      };
      /** @description Optional JSON payload template using CEL expressions */
      payloadTemplate?: string;
    };
    /** @description Header value that can be provided inline or via secret reference */
    NotificationWebhookHeaderValue: {
      /** @description Inline header value */
      value?: string;
      valueFrom?: components['schemas']['NotificationSecretValueFrom'];
    };
    /** @description How to obtain a secret value */
    NotificationSecretValueFrom: {
      secretKeyRef?: components['schemas']['NotificationSecretKeyRef'];
    };
    /** @description Reference to a specific key in a Kubernetes secret */
    NotificationSecretKeyRef: {
      /**
       * @description Name of the Kubernetes secret
       * @example smtp-credentials
       */
      name?: string;
      /**
       * @description Key within the secret
       * @example password
       */
      key?: string;
    };
    /** @description Request body for creating a git secret */
    CreateGitSecretRequest: {
      /**
       * @description Name of the git secret
       * @example my-git-secret
       */
      secretName: string;
      /**
       * @description Authentication type
       * @example basic-auth
       * @enum {string}
       */
      secretType: 'basic-auth' | 'ssh-auth';
      /** @description Username for basic authentication (optional) */
      username?: string;
      /** @description Authentication token (required for basic-auth) */
      token?: string;
      /** @description SSH private key (required for ssh-auth) */
      sshKey?: string;
      /** @description SSH key ID for AWS CodeCommit (optional for ssh-auth) */
      sshKeyId?: string;
    };
    /** @description Git secret resource */
    GitSecretResponse: {
      /**
       * @description Name of the git secret
       * @example my-git-secret
       */
      name?: string;
      /**
       * @description Namespace of the git secret
       * @example my-namespace
       */
      namespace?: string;
    };
    /** @description List of git secrets */
    GitSecretListResponse: {
      /** @description List of git secrets */
      items: components['schemas']['GitSecretResponse'][];
      /** @description Total number of items */
      totalCount?: number;
      /** @description Current page number */
      page?: number;
      /** @description Number of items per page */
      pageSize?: number;
    };
  };
  responses: {
    /** @description Invalid request parameters */
    BadRequest: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "error": "Invalid request: name is required",
         *       "code": "BAD_REQUEST",
         *       "details": [
         *         {
         *           "field": "name",
         *           "message": "is required"
         *         }
         *       ]
         *     }
         */
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Authentication required or token invalid */
    Unauthorized: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "error": "Authentication required",
         *       "code": "UNAUTHORIZED"
         *     }
         */
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Insufficient permissions to access the resource */
    Forbidden: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "error": "You do not have permission to access this resource",
         *       "code": "FORBIDDEN"
         *     }
         */
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Resource not found */
    NotFound: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "error": "Project 'my-project' not found",
         *       "code": "NOT_FOUND"
         *     }
         */
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Resource already exists */
    Conflict: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "error": "Project 'my-project' already exists",
         *       "code": "CONFLICT"
         *     }
         */
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Internal server error */
    InternalError: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        /**
         * @example {
         *       "error": "Internal server error",
         *       "code": "INTERNAL_ERROR"
         *     }
         */
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
  };
  parameters: {
    /** @description Namespace name */
    NamespaceNameParam: string;
    /** @description Project name */
    ProjectNameParam: string;
    /** @description Build plane name */
    BuildPlaneNameParam: string;
    /** @description Filter resources by project name */
    ProjectQueryParam: string;
    /** @description Filter resources by component name */
    ComponentQueryParam: string;
    /** @description Filter resources by environment name */
    EnvironmentQueryParam: string;
    /** @description Workload name */
    WorkloadNameParam: string;
    /** @description Environment name */
    EnvironmentNameParam: string;
    /** @description Environment name for component-scoped operations */
    ComponentEnvironmentNameParam: string;
    /** @description DataPlane name */
    DataPlaneNameParam: string;
    /** @description ClusterDataPlane name */
    ClusterDataPlaneNameParam: string;
    /** @description ObservabilityPlane name */
    ObservabilityPlaneNameParam: string;
    /** @description ClusterObservabilityPlane name */
    ClusterObservabilityPlaneNameParam: string;
    /** @description ComponentType name */
    ComponentTypeNameParam: string;
    /** @description ClusterComponentType name */
    ClusterComponentTypeNameParam: string;
    /** @description ClusterTrait name */
    ClusterTraitNameParam: string;
    /** @description Trait name */
    TraitNameParam: string;
    /** @description Secret reference name */
    SecretReferenceNameParam: string;
    /** @description Deployment pipeline name */
    DeploymentPipelineNameParam: string;
    /** @description Observability alerts notification channel name */
    ObservabilityAlertsNotificationChannelNameParam: string;
    /** @description Workflow name */
    WorkflowNameParam: string;
    /** @description ComponentWorkflow name */
    ComponentWorkflowNameParam: string;
    /** @description Component name */
    ComponentNameParam: string;
    /** @description Workflow run name */
    WorkflowRunNameParam: string;
    /** @description Release binding name */
    ReleaseBindingNameParam: string;
    /** @description Component release name */
    ComponentReleaseNameParam: string;
    /** @description Release name */
    ReleaseNameParam: string;
    /** @description Role name */
    RoleNameParam: string;
    /** @description Role mapping ID */
    MappingIdParam: number;
    /** @description Git secret name */
    GitSecretNameParam: string;
    /** @description Maximum number of items to return per page */
    LimitParam: number;
    /**
     * @description Opaque pagination cursor from a previous response.
     *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
     */
    CursorParam: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  getHealth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Server is healthy */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/plain': string;
        };
      };
    };
  };
  getReady: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Server is ready */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/plain': string;
        };
      };
    };
  };
  getVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Version information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
    };
  };
  getOpenAPISpec: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OpenAPI specification */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': Record<string, never>;
        };
      };
    };
  };
  getOAuthProtectedResourceMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OAuth protected resource metadata */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['OAuthProtectedResourceMetadata'];
        };
      };
    };
  };
  listNamespaces: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of namespaces */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['NamespaceList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createNamespace: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Namespace'];
      };
    };
    responses: {
      /** @description Namespace created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Namespace'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getNamespace: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Namespace details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Namespace'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateNamespace: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Namespace'];
      };
    };
    responses: {
      /** @description Namespace updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Namespace'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deleteNamespace: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Namespace deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listProjects: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of projects */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ProjectList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  createProject: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Project'];
      };
    };
    responses: {
      /** @description Project created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Project'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getProject: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Project details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Project'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateProject: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Project'];
      };
    };
    responses: {
      /** @description Project updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Project'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteProject: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Project deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listComponents: {
    parameters: {
      query?: {
        /** @description Filter resources by project name */
        project?: components['parameters']['ProjectQueryParam'];
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of components */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  createComponent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Component'];
      };
    };
    responses: {
      /** @description Component created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Component'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  listEnvironments: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of environments */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EnvironmentList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createEnvironment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Environment'];
      };
    };
    responses: {
      /** @description Environment created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Environment'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getEnvironment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Environment name */
        envName: components['parameters']['EnvironmentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Environment details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Environment'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateEnvironment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Environment name */
        envName: components['parameters']['EnvironmentNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Environment'];
      };
    };
    responses: {
      /** @description Environment updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Environment'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteEnvironment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Environment name */
        envName: components['parameters']['EnvironmentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Environment deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getEnvironmentObserverURL: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Environment name */
        envName: components['parameters']['EnvironmentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Observer URL information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObserverURLResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getRCAAgentURL: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Environment name */
        envName: components['parameters']['EnvironmentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description RCA agent URL information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RCAAgentURLResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listDataPlanes: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of data planes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DataPlaneList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createDataPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DataPlane'];
      };
    };
    responses: {
      /** @description DataPlane created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DataPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getDataPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description DataPlane name */
        dpName: components['parameters']['DataPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DataPlane details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DataPlane'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateDataPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description DataPlane name */
        dpName: components['parameters']['DataPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DataPlane'];
      };
    };
    responses: {
      /** @description DataPlane updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DataPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteDataPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description DataPlane name */
        dpName: components['parameters']['DataPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description DataPlane deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listBuildPlanes: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of build planes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BuildPlaneList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createBuildPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BuildPlane'];
      };
    };
    responses: {
      /** @description BuildPlane created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BuildPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getBuildPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Build plane name */
        buildPlaneName: components['parameters']['BuildPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Build plane details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BuildPlane'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateBuildPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Build plane name */
        buildPlaneName: components['parameters']['BuildPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BuildPlane'];
      };
    };
    responses: {
      /** @description BuildPlane updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BuildPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteBuildPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Build plane name */
        buildPlaneName: components['parameters']['BuildPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description BuildPlane deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listObservabilityPlanes: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of observability planes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObservabilityPlaneList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createObservabilityPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ObservabilityPlane'];
      };
    };
    responses: {
      /** @description ObservabilityPlane created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObservabilityPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getObservabilityPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description ObservabilityPlane name */
        observabilityPlaneName: components['parameters']['ObservabilityPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Observability plane details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObservabilityPlane'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateObservabilityPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description ObservabilityPlane name */
        observabilityPlaneName: components['parameters']['ObservabilityPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ObservabilityPlane'];
      };
    };
    responses: {
      /** @description ObservabilityPlane updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObservabilityPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteObservabilityPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description ObservabilityPlane name */
        observabilityPlaneName: components['parameters']['ObservabilityPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description ObservabilityPlane deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listClusterDataPlanes: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of cluster data planes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterDataPlaneList'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createClusterDataPlane: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterDataPlane'];
      };
    };
    responses: {
      /** @description ClusterDataPlane created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterDataPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterDataPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterDataPlane name */
        cdpName: components['parameters']['ClusterDataPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description ClusterDataPlane details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterDataPlane'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateClusterDataPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterDataPlane name */
        cdpName: components['parameters']['ClusterDataPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterDataPlane'];
      };
    };
    responses: {
      /** @description ClusterDataPlane updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterDataPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteClusterDataPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterDataPlane name */
        cdpName: components['parameters']['ClusterDataPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description ClusterDataPlane deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listClusterBuildPlanes: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of cluster build planes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterBuildPlaneList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createClusterBuildPlane: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterBuildPlane'];
      };
    };
    responses: {
      /** @description ClusterBuildPlane created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterBuildPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterBuildPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the cluster build plane */
        clusterBuildPlaneName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster build plane details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterBuildPlane'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateClusterBuildPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the cluster build plane */
        clusterBuildPlaneName: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterBuildPlane'];
      };
    };
    responses: {
      /** @description ClusterBuildPlane updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterBuildPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteClusterBuildPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Name of the cluster build plane */
        clusterBuildPlaneName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description ClusterBuildPlane deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listClusterObservabilityPlanes: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of cluster observability planes */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterObservabilityPlaneList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createClusterObservabilityPlane: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterObservabilityPlane'];
      };
    };
    responses: {
      /** @description ClusterObservabilityPlane created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterObservabilityPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterObservabilityPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterObservabilityPlane name */
        clusterObservabilityPlaneName: components['parameters']['ClusterObservabilityPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster observability plane details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterObservabilityPlane'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateClusterObservabilityPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterObservabilityPlane name */
        clusterObservabilityPlaneName: components['parameters']['ClusterObservabilityPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterObservabilityPlane'];
      };
    };
    responses: {
      /** @description ClusterObservabilityPlane updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterObservabilityPlane'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteClusterObservabilityPlane: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterObservabilityPlane name */
        clusterObservabilityPlaneName: components['parameters']['ClusterObservabilityPlaneNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description ClusterObservabilityPlane deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listClusterComponentTypes: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of cluster component types */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterComponentTypeList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createClusterComponentType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterComponentType'];
      };
    };
    responses: {
      /** @description Cluster component type created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterComponentType'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterComponentType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterComponentType name */
        cctName: components['parameters']['ClusterComponentTypeNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster component type details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterComponentType'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateClusterComponentType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterComponentType name */
        cctName: components['parameters']['ClusterComponentTypeNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterComponentType'];
      };
    };
    responses: {
      /** @description Cluster component type updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterComponentType'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteClusterComponentType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterComponentType name */
        cctName: components['parameters']['ClusterComponentTypeNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description ClusterComponentType deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterComponentTypeSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterComponentType name */
        cctName: components['parameters']['ClusterComponentTypeNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster component type schema */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listClusterTraits: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of cluster traits */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterTraitList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createClusterTrait: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterTrait'];
      };
    };
    responses: {
      /** @description Cluster trait created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterTrait'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterTrait: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterTrait name */
        clusterTraitName: components['parameters']['ClusterTraitNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster trait details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterTrait'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateClusterTrait: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterTrait name */
        clusterTraitName: components['parameters']['ClusterTraitNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClusterTrait'];
      };
    };
    responses: {
      /** @description Cluster trait updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClusterTrait'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteClusterTrait: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterTrait name */
        clusterTraitName: components['parameters']['ClusterTraitNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description ClusterTrait deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterTraitSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ClusterTrait name */
        clusterTraitName: components['parameters']['ClusterTraitNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster trait schema */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listComponentTypes: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of component types */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentTypeList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createComponentType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ComponentType'];
      };
    };
    responses: {
      /** @description Component type created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentType'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getComponentType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description ComponentType name */
        ctName: components['parameters']['ComponentTypeNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Component type details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentType'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateComponentType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description ComponentType name */
        ctName: components['parameters']['ComponentTypeNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ComponentType'];
      };
    };
    responses: {
      /** @description Component type updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentType'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteComponentType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description ComponentType name */
        ctName: components['parameters']['ComponentTypeNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Component type deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getComponentTypeSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description ComponentType name */
        ctName: components['parameters']['ComponentTypeNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Component type schema */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listTraits: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of traits */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TraitList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createTrait: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Trait'];
      };
    };
    responses: {
      /** @description Trait created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Trait'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getTrait: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Trait name */
        traitName: components['parameters']['TraitNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Trait details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Trait'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateTrait: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Trait name */
        traitName: components['parameters']['TraitNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Trait'];
      };
    };
    responses: {
      /** @description Trait updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Trait'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteTrait: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Trait name */
        traitName: components['parameters']['TraitNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Trait deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getTraitSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Trait name */
        traitName: components['parameters']['TraitNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Trait schema */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listWorkflows: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of workflows */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  getWorkflowSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Workflow name */
        workflowName: components['parameters']['WorkflowNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow schema */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listWorkflowRuns: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of workflow runs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowRunList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createWorkflowRun: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateWorkflowRunRequest'];
      };
    };
    responses: {
      /** @description Workflow run created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowRun'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getWorkflowRun: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Workflow run name */
        runName: components['parameters']['WorkflowRunNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow run details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowRun'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getWorkflowRunStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Workflow run name */
        runName: components['parameters']['WorkflowRunNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow run status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowRunStatusResponse'];
        };
      };
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getWorkflowRunLogs: {
    parameters: {
      query?: {
        /** @description Filter logs by step name */
        step?: string;
        /** @description Return logs newer than a relative duration in seconds */
        sinceSeconds?: number;
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Workflow run name */
        runName: components['parameters']['WorkflowRunNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow run logs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowRunLogEntry'][];
        };
      };
      400: components['responses']['BadRequest'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getWorkflowRunEvents: {
    parameters: {
      query?: {
        /** @description Filter events by step name */
        step?: string;
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Workflow run name */
        runName: components['parameters']['WorkflowRunNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow run events */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkflowRunEventEntry'][];
        };
      };
      400: components['responses']['BadRequest'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listComponentWorkflows: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of component workflows */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentWorkflowTemplateList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  getComponentWorkflowSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description ComponentWorkflow name */
        cwName: components['parameters']['ComponentWorkflowNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Component workflow schema */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getComponent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Component details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Component'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateComponent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Component'];
      };
    };
    responses: {
      /** @description Component updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Component'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteComponent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Component deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getComponentSchema: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Component schema */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getReleaseResourceTree: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
        /** @description Environment name for component-scoped operations */
        environmentName: components['parameters']['ComponentEnvironmentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Resource tree for the active release */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResourceTreeResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getReleaseResourceEvents: {
    parameters: {
      query: {
        /** @description Kind of the resource */
        kind: string;
        /** @description Name of the resource */
        name: string;
        /** @description Namespace of the resource */
        namespace?: string;
        /** @description UID of the resource for precise event matching */
        uid?: string;
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
        /** @description Environment name for component-scoped operations */
        environmentName: components['parameters']['ComponentEnvironmentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Events for the specified resource */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResourceEventsResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getReleaseResourcePodLogs: {
    parameters: {
      query: {
        /** @description Name of the pod */
        name: string;
        /** @description Namespace of the pod */
        namespace: string;
        /** @description Specific container name to get logs from */
        container?: string;
        /** @description Only return logs newer than this many seconds */
        sinceSeconds?: number;
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
        /** @description Environment name for component-scoped operations */
        environmentName: components['parameters']['ComponentEnvironmentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Logs for the specified pod */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResourcePodLogsResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deployRelease: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeployReleaseRequest'];
      };
    };
    responses: {
      /** @description Release deployed */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  promoteComponent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PromoteComponentRequest'];
      };
    };
    responses: {
      /** @description Component promoted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  generateRelease: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GenerateReleaseRequest'];
      };
    };
    responses: {
      /** @description Component release created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentRelease'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateComponentWorkflowParameters: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateComponentWorkflowRequest'];
      };
    };
    responses: {
      /** @description Workflow parameters updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Component'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listComponentWorkflowRuns: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of workflow runs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentWorkflowRunList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  createComponentWorkflowRun: {
    parameters: {
      query?: {
        /** @description Specific git commit SHA to build (optional) */
        commit?: string;
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow run triggered */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentWorkflowRun'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getComponentWorkflowRun: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Project name */
        projectName: components['parameters']['ProjectNameParam'];
        /** @description Component name */
        componentName: components['parameters']['ComponentNameParam'];
        /** @description Workflow run name */
        runName: components['parameters']['WorkflowRunNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workflow run details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentWorkflowRun'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listActions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of actions */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': string[];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  evaluates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EvaluateRequest'][];
      };
    };
    responses: {
      /** @description Authorization decisions in the same order as the input requests (decision[i] corresponds to request[i]) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Decision'][];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  getSubjectProfile: {
    parameters: {
      query?: {
        /** @description Namespace scope */
        namespace?: string;
        /** @description Project scope */
        project?: string;
        /** @description Component scope */
        component?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Subject profile */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserCapabilitiesResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  listClusterRoles: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of cluster roles */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzClusterRoleList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createClusterRole: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthzClusterRole'];
      };
    };
    responses: {
      /** @description Cluster role created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzClusterRole'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterRole: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Cluster role name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster role details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzClusterRole'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateClusterRole: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Cluster role name */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthzClusterRole'];
      };
    };
    responses: {
      /** @description Cluster role updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzClusterRole'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deleteClusterRole: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Cluster role name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster role deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  listClusterRoleBindings: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of cluster role bindings */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzClusterRoleBindingList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createClusterRoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthzClusterRoleBinding'];
      };
    };
    responses: {
      /** @description Cluster role binding created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzClusterRoleBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getClusterRoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Cluster role binding name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster role binding details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzClusterRoleBinding'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateClusterRoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Cluster role binding name */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthzClusterRoleBinding'];
      };
    };
    responses: {
      /** @description Cluster role binding updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzClusterRoleBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteClusterRoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Cluster role binding name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Cluster role binding deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listNamespaceRoles: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of namespace roles */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzRoleList'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createNamespaceRole: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthzRole'];
      };
    };
    responses: {
      /** @description Namespace role created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzRole'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getNamespaceRole: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Namespace role name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Namespace role details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzRole'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateNamespaceRole: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Namespace role name */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthzRole'];
      };
    };
    responses: {
      /** @description Namespace role updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzRole'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deleteNamespaceRole: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Namespace role name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Namespace role deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  listNamespaceRoleBindings: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of namespace role bindings */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzRoleBindingList'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createNamespaceRoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthzRoleBinding'];
      };
    };
    responses: {
      /** @description Namespace role binding created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzRoleBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getNamespaceRoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Namespace role binding name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Namespace role binding details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzRoleBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateNamespaceRoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Namespace role binding name */
        name: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthzRoleBinding'];
      };
    };
    responses: {
      /** @description Namespace role binding updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AuthzRoleBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteNamespaceRoleBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Namespace role binding name */
        name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Namespace role binding deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listUserTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of configured user types */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserTypeConfig'][];
        };
      };
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  handleGitHubWebhook: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Webhook processed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WebhookEventResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  handleGitLabWebhook: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Webhook processed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WebhookEventResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  handleBitbucketWebhook: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          [key: string]: unknown;
        };
      };
    };
    responses: {
      /** @description Webhook processed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WebhookEventResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      500: components['responses']['InternalError'];
    };
  };
  listSecretReferences: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of secret references */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SecretReferenceList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createSecretReference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SecretReference'];
      };
    };
    responses: {
      /** @description Secret reference created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SecretReference'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getSecretReference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Secret reference name */
        secretReferenceName: components['parameters']['SecretReferenceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Secret reference details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SecretReference'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateSecretReference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Secret reference name */
        secretReferenceName: components['parameters']['SecretReferenceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SecretReference'];
      };
    };
    responses: {
      /** @description Secret reference updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SecretReference'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deleteSecretReference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Secret reference name */
        secretReferenceName: components['parameters']['SecretReferenceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Secret reference deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listWorkloads: {
    parameters: {
      query?: {
        /** @description Filter resources by component name */
        component?: components['parameters']['ComponentQueryParam'];
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of workloads */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['WorkloadList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  createWorkload: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Workload'];
      };
    };
    responses: {
      /** @description Workload created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Workload'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getWorkload: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Workload name */
        workloadName: components['parameters']['WorkloadNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workload details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Workload'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateWorkload: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Workload name */
        workloadName: components['parameters']['WorkloadNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Workload'];
      };
    };
    responses: {
      /** @description Workload updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Workload'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deleteWorkload: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Workload name */
        workloadName: components['parameters']['WorkloadNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Workload deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listComponentReleases: {
    parameters: {
      query?: {
        /** @description Filter resources by component name */
        component?: components['parameters']['ComponentQueryParam'];
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of component releases */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentReleaseList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getComponentRelease: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Component release name */
        componentReleaseName: components['parameters']['ComponentReleaseNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Component release details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ComponentRelease'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listReleases: {
    parameters: {
      query?: {
        /** @description Filter resources by component name */
        component?: components['parameters']['ComponentQueryParam'];
        /** @description Filter resources by environment name */
        environment?: components['parameters']['EnvironmentQueryParam'];
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of releases */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  getRelease: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Release name */
        releaseName: components['parameters']['ReleaseNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Release details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Release'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listReleaseBindings: {
    parameters: {
      query?: {
        /** @description Filter resources by component name */
        component?: components['parameters']['ComponentQueryParam'];
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of release bindings */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseBindingList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  createReleaseBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseBinding'];
      };
    };
    responses: {
      /** @description Release binding created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getReleaseBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Release binding name */
        releaseBindingName: components['parameters']['ReleaseBindingNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Release binding details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseBinding'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateReleaseBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Release binding name */
        releaseBindingName: components['parameters']['ReleaseBindingNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ReleaseBinding'];
      };
    };
    responses: {
      /** @description Release binding updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ReleaseBinding'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deleteReleaseBinding: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Release binding name */
        releaseBindingName: components['parameters']['ReleaseBindingNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Release binding deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listDeploymentPipelines: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of deployment pipelines */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeploymentPipelineList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createDeploymentPipeline: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeploymentPipeline'];
      };
    };
    responses: {
      /** @description Deployment pipeline created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeploymentPipeline'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getDeploymentPipeline: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Deployment pipeline name */
        deploymentPipelineName: components['parameters']['DeploymentPipelineNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Deployment pipeline details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeploymentPipeline'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateDeploymentPipeline: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Deployment pipeline name */
        deploymentPipelineName: components['parameters']['DeploymentPipelineNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeploymentPipeline'];
      };
    };
    responses: {
      /** @description Deployment pipeline updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeploymentPipeline'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deleteDeploymentPipeline: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Deployment pipeline name */
        deploymentPipelineName: components['parameters']['DeploymentPipelineNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Deployment pipeline deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listObservabilityAlertsNotificationChannels: {
    parameters: {
      query?: {
        /** @description Maximum number of items to return per page */
        limit?: components['parameters']['LimitParam'];
        /**
         * @description Opaque pagination cursor from a previous response.
         *     Pass the `nextCursor` value from pagination metadata to fetch the next page.
         */
        cursor?: components['parameters']['CursorParam'];
      };
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of observability alerts notification channels */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObservabilityAlertsNotificationChannelList'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createObservabilityAlertsNotificationChannel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ObservabilityAlertsNotificationChannel'];
      };
    };
    responses: {
      /** @description Observability alerts notification channel created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObservabilityAlertsNotificationChannel'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  getObservabilityAlertsNotificationChannel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Observability alerts notification channel name */
        observabilityAlertsNotificationChannelName: components['parameters']['ObservabilityAlertsNotificationChannelNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Observability alerts notification channel details */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObservabilityAlertsNotificationChannel'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  updateObservabilityAlertsNotificationChannel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Observability alerts notification channel name */
        observabilityAlertsNotificationChannelName: components['parameters']['ObservabilityAlertsNotificationChannelNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ObservabilityAlertsNotificationChannel'];
      };
    };
    responses: {
      /** @description Observability alerts notification channel updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ObservabilityAlertsNotificationChannel'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  deleteObservabilityAlertsNotificationChannel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Observability alerts notification channel name */
        observabilityAlertsNotificationChannelName: components['parameters']['ObservabilityAlertsNotificationChannelNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Observability alerts notification channel deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
  listGitSecrets: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List of git secrets */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GitSecretListResponse'];
        };
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      500: components['responses']['InternalError'];
    };
  };
  createGitSecret: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateGitSecretRequest'];
      };
    };
    responses: {
      /** @description Git secret created successfully */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GitSecretResponse'];
        };
      };
      400: components['responses']['BadRequest'];
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      409: components['responses']['Conflict'];
      500: components['responses']['InternalError'];
    };
  };
  deleteGitSecret: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace name */
        namespaceName: components['parameters']['NamespaceNameParam'];
        /** @description Git secret name */
        gitSecretName: components['parameters']['GitSecretNameParam'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Git secret deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['Unauthorized'];
      403: components['responses']['Forbidden'];
      404: components['responses']['NotFound'];
      500: components['responses']['InternalError'];
    };
  };
}
